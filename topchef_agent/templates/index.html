<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Top Chef France â€“ Chef Explorer</title>
    <link rel="icon" type="image/png" href="/static/favicon.png">
    <meta name="description" content="Discover France's top chefs by location, season, and status. Explore culinary excellence with Top Chef France.">
    <meta name="theme-color" content="#111111"> <!-- Updated theme color -->
    <link href="https://fonts.googleapis.com/css?family=Montserrat:700&display=swap" rel="stylesheet"> <!-- Only Montserrat Bold -->
    <!-- Leaflet CSS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
          integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
          crossorigin=""/>
    <!-- Leaflet JavaScript -->
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
            integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
            crossorigin=""></script>

    <style>
        :root {
            /* M6 Top Chef Inspired Palette */
            --m6-bg: #111111; /* Dark background */
            --m6-bg-secondary: #222222; /* Slightly lighter bg for elements */
            --m6-border: #444444; /* Borders */
            --m6-text-primary: #e0e0e0; /* Primary light text */
            --m6-text-secondary: #a0a0a0; /* Secondary light text */
            --m6-text-dark: #111111; /* Dark text for light backgrounds */
            --tcf-yellow: #ffc72c; /* Accent yellow */
            --m6-white: #ffffff;
            --m6-shadow: none; /* Flatten design */
            --m6-shadow-light: none; /* Flatten design */
        }
        html, body {
            height: 100%;
            margin: 0;
            padding: 0;
            font-family: Arial, Helvetica, sans-serif; /* Standard sans-serif */
            background-color: var(--m6-bg);
            color: var(--m6-text-primary);
            display: flex;
            flex-direction: column;
            font-size: 14px; /* Base font size */
        }

        .header {
            padding: 15px 30px; /* Reduced padding */
            background-color: var(--m6-bg-secondary); /* Use secondary bg */
            color: var(--m6-text-primary);
            box-shadow: var(--m6-shadow); /* Removed shadow */
            border-bottom: 3px solid var(--m6-border); /* Thinner, darker border */
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-shrink: 0; /* Prevent header from shrinking */
        }
        .header .title-group h1 {
            font-family: 'Montserrat', sans-serif; /* Keep Montserrat for main title */
            font-weight: 700;
            font-size: 1.8em; /* Reduced size */
            margin: 0;
            letter-spacing: 1px;
            color: var(--tcf-yellow); /* Keep yellow accent */
            text-shadow: none; /* Remove text shadow */
        }
        .header .title-group p {
            margin: 2px 0 0 1px; /* Adjusted margin */
            font-size: 1em; /* Reduced size */
            color: var(--m6-text-secondary); /* Use secondary text color */
            font-family: Arial, Helvetica, sans-serif; /* Standard sans-serif */
            font-style: normal; /* Remove italic */
            letter-spacing: 0.5px;
        }
        #view-toggle-button {
            padding: 8px 18px; /* Adjusted padding */
            font-size: 0.9em; /* Adjusted size */
            font-family: Arial, Helvetica, sans-serif; /* Standard font */
            cursor: pointer;
            background-color: var(--m6-bg-secondary); /* Match header bg */
            color: var(--m6-text-primary); /* Light text */
            border: 1px solid var(--m6-border); /* Use theme border */
            border-radius: 3px; /* Sharper corners */
            box-shadow: var(--m6-shadow-light); /* Removed shadow */
            transition: background-color 0.2s, color 0.2s, border-color 0.2s;
        }
        #view-toggle-button:hover {
            background-color: var(--m6-border); /* Darker bg on hover */
            border-color: var(--tcf-yellow); /* Yellow border on hover */
            color: var(--tcf-yellow); /* Yellow text on hover */
            transform: none; /* Remove lift */
        }

        /* Style for the Season Filter Select */
        #season-filter {
            padding: 7px 25px 7px 10px; /* Adjusted padding */
            font-size: 0.9em; /* Adjusted size */
            font-family: Arial, Helvetica, sans-serif; /* Standard font */
            cursor: pointer;
            background-color: var(--m6-bg-secondary); /* Match header bg */
            color: var(--m6-text-primary); /* Light text */
            border: 1px solid var(--m6-border); /* Use theme border */
            border-radius: 3px; /* Sharper corners */
            margin-right: 15px;
            box-shadow: var(--m6-shadow-light); /* Removed shadow */
            appearance: none;
            -webkit-appearance: none;
            -moz-appearance: none;
            /* Simple arrow using SVG */
            background-image: url('data:image/svg+xml;charset=US-ASCII,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20viewBox%3D%220%200%2010%205%22%3E%3Cpath%20fill%3D%22%23a0a0a0%22%20d%3D%22M0%200l5%205%205-5z%22%2F%3E%3C%2Fsvg%3E');
            background-repeat: no-repeat;
            background-position: right 8px top 50%;
            background-size: 10px auto;
            transition: border-color 0.2s;
        }
        #season-filter:hover {
            border-color: var(--tcf-yellow); /* Yellow border on hover */
        }
        #season-filter:focus {
            outline: none;
            border-color: var(--tcf-yellow);
            box-shadow: 0 0 0 2px rgba(255, 199, 44, 0.4); /* Subtle yellow focus ring */
        }
        /* Label for the filter */
        label[for="season-filter"] {
            color: var(--m6-text-secondary); /* Use secondary text color */
            margin-right: 8px;
            font-family: Arial, Helvetica, sans-serif; /* Standard font */
            font-size: 0.9em; /* Adjusted size */
        }


        .main-content {
            display: flex;
            flex-grow: 1;
            overflow: hidden; /* Prevent content overflow */
            padding: 15px; /* Increased padding */
            gap: 15px; /* Increased gap */
            min-height: 0; /* Allow flex items to shrink properly */
        }

        .primary-view-container {
            flex-basis: 65%; /* Use flex-basis */
            min-width: 0; /* Allow shrinking */
            position: relative;
            border-radius: 3px; /* Sharper corners */
            box-shadow: var(--m6-shadow); /* Removed shadow */
            background-color: var(--m6-white); /* Keep white for map/table bg */
            overflow: hidden;
            border: 1px solid var(--m6-border); /* Add border */
            display: flex; /* Ensure map/table fills container */
            flex-direction: column;
        }

        #map {
            height: 100%;
            width: 100%;
            flex-grow: 1; /* Allow map to fill space */
        }

        .sidebar {
            flex-basis: 35%; /* Use flex-basis */
            min-width: 0; /* Allow shrinking */
            display: flex;
            flex-direction: column;
            background: var(--m6-bg-secondary); /* Use secondary bg */
            border-radius: 3px; /* Sharper corners */
            border: 1px solid var(--m6-border); /* Use theme border */
            box-shadow: var(--m6-shadow); /* Removed shadow */
            overflow: hidden; /* Prevents content spill */
        }

        /* Simplified Sidebar Headers */
        .sidebar h2, .background-header span, #interactive-chat-header span {
            font-family: Arial, Helvetica, sans-serif; /* Standard font */
            font-size: 1em; /* Adjusted size */
            font-weight: bold;
            color: var(--m6-text-primary); /* Light text */
            letter-spacing: 0.5px;
            margin: 0; /* Reset margin */
        }
        .header-row, #background-header, #interactive-chat-header {
            background: none; /* Remove gradient/color */
            padding: 10px 15px; /* Adjusted padding */
            box-shadow: none; /* Remove shadow */
            border-radius: 0; /* Remove rounding */
            border-bottom: 1px solid var(--m6-border); /* Add bottom border */
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-shrink: 0; /* Prevent headers from shrinking */
        }
        #main-chat-container {
            flex-basis: 60%;
            border-bottom: none; /* Remove yellow border */
            background: transparent;
            display: flex;
            flex-direction: column;
            overflow: hidden; /* Contain children */
            min-height: 0; /* Allow shrinking */
        }
        #background-work-container {
            flex-basis: 40%;
            background: transparent;
            display: flex;
            flex-direction: column;
            border-top: 1px solid var(--m6-border); /* Add separator */
            overflow: hidden; /* Contain children */
            min-height: 0; /* Allow shrinking */
        }
        #interactive-chat-container {
            background: transparent;
            border-top: 1px solid var(--m6-border); /* Use standard border */
            flex-basis: 35%; /* Keep ratio */
            min-height: 180px; /* Keep min height for usability */
            display: flex;
            flex-direction: column;
            overflow: hidden; /* Contain children */
        }
        #chat-log-area, #background-log-area, #interactive-chat-log-area {
            flex-grow: 1;
            overflow-y: auto;
            padding: 10px;
            background: transparent; /* Remove subtle background */
            min-height: 0; /* Allow shrinking */
        }
        #chat-log-area { color: var(--m6-text-primary); }
        #background-log-area { color: var(--m6-text-secondary); } /* Keep secondary for background */
        #interactive-chat-log-area { color: var(--m6-text-primary); }

        /* M6 Theme Chat Bubbles & Log Entries */
        #chat-log-area .log-entry.log-entry-stephai-botenberg,
        #interactive-chat-log-area .ai-msg {
            background: var(--m6-bg-secondary); /* Use secondary bg */
            color: var(--m6-text-primary); /* Light text */
            border: 1px solid var(--m6-border);
            box-shadow: none;
            border-radius: 6px; /* Slightly rounded */
            padding: 10px 15px;
            margin: 8px 40px 8px 8px; /* Adjust margins */
            text-align: left;
        }
        #chat-log-area .log-entry.log-entry-scheduler,
        #interactive-chat-log-area .user-msg {
            background: #333; /* Slightly different dark bg for user/scheduler */
            color: var(--m6-text-primary); /* Light text */
            border: 1px solid var(--m6-border);
            box-shadow: none;
            border-radius: 6px;
            padding: 10px 15px;
            margin: 8px 8px 8px 40px; /* Adjust margins */
            text-align: right;
        }

        /* General Log Entry Styling */
        .log-entry {
            margin-bottom: 8px; /* Reduced margin */
            padding-bottom: 8px;
            border-bottom: 1px solid var(--m6-border); /* Use theme border */
        }
        .log-entry:last-child { border-bottom: none; }

        /* Background Log Specific Styling */
        #background-log-area .log-entry {
            background: none; /* Remove specific background */
            color: var(--m6-text-secondary); /* Use secondary text */
            border-radius: 0;
            padding: 4px 0; /* Minimal padding */
            margin-bottom: 4px;
            border: none; /* Remove border */
            font-size: 0.85em; /* Smaller font */
            border-bottom: none; /* Override general log entry border */
        }

        .log-timestamp {
            color: var(--m6-text-secondary); /* Use secondary text */
            margin-right: 8px;
            font-size: 0.85em; /* Match background log */
            opacity: 0.7;
            font-family: Arial, Helvetica, sans-serif; /* Standard font */
        }
        /* Timestamp inside chat bubbles */
        #chat-log-area .log-entry .log-timestamp,
        #interactive-chat-log-area .log-entry .log-timestamp {
             color: var(--m6-text-secondary);
             opacity: 0.7;
        }
        .log-role {
            font-weight: bold;
            margin-right: 5px;
            font-family: Arial, Helvetica, sans-serif; /* Standard font */
            color: var(--m6-text-secondary); /* Use secondary text color */
        }
        /* Highlight StephAI role slightly in background log */
         #background-log-area .role-StephAI-Botenberg .log-role {
            color: var(--m6-text-primary);
         }


        #database-table-container {
            height: 100%;
            width: 100%;
            padding: 20px; /* Adjusted padding */
            overflow: auto;
            display: none;
            box-sizing: border-box;
            flex-direction: column;
            border-radius: 0; /* Remove rounding */
            background: var(--m6-white);
            box-shadow: none;
            color: var(--m6-text-dark);
        }

        #database-table-container h2 {
            margin: 0 0 15px 0;
            padding-bottom: 10px;
            border-bottom: 2px solid var(--tcf-yellow); /* Keep yellow accent border */
            font-size: 1.3em; /* Adjusted size */
            color: var(--m6-text-dark); /* Dark text */
            font-family: Arial, Helvetica, sans-serif; /* Standard font */
            font-weight: bold;
        }

        .db-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.9em; /* Adjusted size */
            font-family: Arial, Helvetica, sans-serif; /* Standard font */
        }

        .db-table th, .db-table td {
            border: 1px solid #ddd; /* Lighter border for table */
            padding: 8px 12px; /* Adjusted padding */
            text-align: left;
            vertical-align: top;
            white-space: normal;
            word-break: break-word;
        }

        .db-table th {
            background-color: #f0f0f0; /* Light grey header */
            color: var(--m6-text-dark); /* Dark text */
            font-family: Arial, Helvetica, sans-serif; /* Standard font */
            font-weight: bold;
            position: sticky;
            top: 0;
            z-index: 1;
            border-bottom: 2px solid #ccc; /* Darker grey bottom border */
        }

        .db-table tr:nth-child(even) {
            background-color: #f9f9f9; /* Very light grey for zebra */
        }

        .db-table tr:hover {
            background-color: #f0f0f0; /* Slightly darker hover */
        }

        .db-table .col-bio {
            max-width: 300px; /* Adjusted width */
            overflow: hidden;
            text-overflow: ellipsis;
        }


        #interactive-chat-input-row {
            display: flex;
            padding: 10px;
            background: var(--m6-bg-secondary); /* Match sidebar bg */
            border-top: 1px solid var(--m6-border); /* Standard border */
            flex-shrink: 0; /* Prevent input row from shrinking */
        }
        
        /* Agent History Link Styling */
        .nav-links {
            display: flex;
            align-items: center;
            margin-right: 20px;
        }
        
        .agent-history-link {
            color: var(--tcf-yellow);
            text-decoration: none;
            font-size: 0.9em;
            padding: 5px 10px;
            border: 1px solid var(--m6-border);
            border-radius: 3px;
            background: var(--m6-bg-secondary);
            transition: all 0.2s ease;
        }
        
        .agent-history-link:hover {
            background: var(--m6-border);
            color: var(--m6-white);
            border-color: var(--tcf-yellow);
        }

        #interactive-chat-input {
            flex: 1;
            padding: 8px 10px;
            font-size: 0.9em;
            border: 1px solid var(--m6-border);
            border-radius: 3px; /* Sharper corners */
            margin-right: 10px;
            background-color: var(--m6-bg); /* Dark input bg */
            color: var(--m6-text-primary); /* Light text */
        }
        #interactive-chat-input:focus {
             outline: none;
             border-color: var(--tcf-yellow);
             box-shadow: 0 0 0 2px rgba(255, 199, 44, 0.4); /* Subtle yellow focus */
        }

        #interactive-chat-send {
            padding: 8px 15px;
            font-size: 0.9em;
            font-family: Arial, Helvetica, sans-serif; /* Standard font */
            background: var(--m6-border); /* Use border color for button */
            color: var(--m6-text-primary); /* Light text */
            border: none;
            border-radius: 3px; /* Sharper corners */
            cursor: pointer;
            transition: background-color 0.2s, color 0.2s;
        }
        #interactive-chat-send:hover {
            background: var(--tcf-yellow); /* Yellow bg on hover */
            color: var(--m6-text-dark); /* Dark text on hover */
            transform: none; /* Remove lift */
        }

        #interactive-chat-send:disabled {
            background: #333; /* Darker disabled bg */
            color: var(--m6-text-secondary); /* Dim text */
            cursor: not-allowed;
            transform: none;
        }


        /* Cleaner Enlarge/Collapse Icons */
        .enlarge-btn, .toggle-icon {
            font-family: sans-serif; /* Use generic for icons */
            font-weight: bold;
            font-size: 1.2em;
            line-height: 1;
        }
        .enlarge-btn {
            background: none;
            border: none;
            cursor: pointer;
            margin-left: 10px;
            color: var(--m6-text-secondary); /* Secondary text color */
            transition: color 0.2s;
            padding: 0;
        }
        .enlarge-btn:hover {
            color: var(--tcf-yellow); /* Yellow on hover */
        }
        .enlarge-btn:focus { outline: none; }

        /* Use +/- for toggle */
        .toggle-icon {
             color: var(--m6-text-secondary);
             margin-left: 5px;
             cursor: pointer; /* Make icon clickable */
        }
        .toggle-icon:hover { color: var(--tcf-yellow); }

        /* Adjust spinner */
        #background-header .spinner {
            /* Add spinner styles if needed, e.g., border color */
            border-top-color: var(--tcf-yellow);
            width: 14px; height: 14px; /* Smaller */
            margin-right: 8px;
        }


        .sidebar.enlarged-agent #main-chat-container,
        .sidebar.enlarged-bg #background-work-container,
        .sidebar.enlarged-interactive #interactive-chat-container {
            flex-basis: 100% !important;
            height: 100%;
            display: flex;
        }

        .sidebar.enlarged-agent #background-work-container,
        .sidebar.enlarged-agent #interactive-chat-container,
        .sidebar.enlarged-bg #main-chat-container,
        .sidebar.enlarged-bg #interactive-chat-container,
        .sidebar.enlarged-interactive #main-chat-container,
        .sidebar.enlarged-interactive #background-work-container {
            display: none !important;
        }

        /* Styles for Map Popups */
        .leaflet-popup-content-wrapper {
            background: var(--m6-bg-secondary); /* Dark popup bg */
            color: var(--m6-text-primary); /* Light text */
            border-radius: 4px; /* Sharper corners */
            box-shadow: none; /* Remove shadow */
            border: 1px solid var(--m6-border);
        }
        .leaflet-popup-content {
            margin: 12px 18px; /* Adjusted padding */
            font-family: Arial, Helvetica, sans-serif; /* Standard font */
            line-height: 1.5;
            font-size: 0.9em;
        }
        .leaflet-popup-content h3 {
            font-family: 'Montserrat', sans-serif; /* Keep Montserrat */
            color: var(--tcf-yellow); /* Yellow title */
            margin: 0 0 8px 0;
            padding-bottom: 4px;
            border-bottom: 1px solid var(--m6-border); /* Theme border */
            font-size: 1.1em;
        }
        .leaflet-popup-content p {
            margin: 4px 0;
        }
        .leaflet-popup-content strong {
            color: var(--m6-text-primary); /* Primary light text for strong */
            font-weight: bold;
        }
        .popup-image {
            max-width: 100%;
            height: auto;
            margin-top: 8px;
            border-radius: 3px;
            border: 1px solid var(--m6-border);
        }
        .missing-data {
            color: var(--m6-text-secondary); /* Secondary text for missing */
            font-style: italic;
            font-size: 0.9em;
        }
        .leaflet-popup-tip {
            background: var(--m6-bg-secondary); /* Match popup bg */
        }


        /* --- Responsive Design --- */
        @media (max-width: 768px) {
            html, body {
                font-size: 13px; /* Slightly smaller base font for mobile */
            }
            .header {
                padding: 10px 15px; /* Reduced header padding */
                flex-direction: column; /* Stack title and controls */
                align-items: flex-start; /* Align items left */
                gap: 10px; /* Add gap between title and controls */
            }
            .header .title-group h1 {
                font-size: 1.5em; /* Smaller title */
            }
             .header .title-group p {
                font-size: 0.9em; /* Smaller subtitle */
            }
            .header > div:last-child { /* Target the controls container */
                 display: flex;
                 width: 100%; /* Make controls take full width */
                 justify-content: space-between; /* Space out controls */
                 align-items: center;
            }
             #season-filter {
                 padding: 6px 20px 6px 8px; /* Adjust padding */
                 font-size: 0.85em;
                 margin-right: 10px; /* Adjust margin */
                 flex-grow: 1; /* Allow filter to take available space */
            }
             #view-toggle-button {
                 padding: 7px 15px; /* Adjust padding */
                 font-size: 0.85em;
            }

            .main-content {
                flex-direction: column; /* Stack main sections */
                padding: 10px; /* Adjust padding */
                gap: 10px; /* Adjust gap */
                overflow-y: auto; /* Allow vertical scroll for the whole content area if needed */
                height: calc(100% - 70px); /* Adjust height considering header */
            }
            .primary-view-container, .sidebar {
                width: 100%; /* Full width */
                flex-basis: auto; /* Reset flex-basis */
                height: 50%; /* Approximate height split, adjust as needed */
                min-height: 300px; /* Ensure minimum usable height */
            }
            .sidebar {
                 height: auto; /* Allow sidebar to grow based on content */
                 min-height: 400px; /* Ensure sidebar is usable */
            }

             /* Adjust sidebar section distribution */
             #main-chat-container, #background-work-container, #interactive-chat-container {
                 flex-basis: auto; /* Let content determine height more */
             }
             #interactive-chat-container {
                 min-height: 150px; /* Slightly smaller min-height */
             }

             /* Ensure table scrolls horizontally if needed */
             .db-table-wrapper {
                 overflow-x: auto;
             }
             #database-table-container {
                 padding: 15px; /* Adjust padding */
             }
             .db-table th, .db-table td {
                 padding: 6px 10px; /* Smaller padding */
                 white-space: nowrap; /* Prevent wrapping in table cells initially */
             }
             .db-table .col-bio {
                 white-space: normal; /* Allow bio to wrap */
             }
        }

        /* --- Animations & Transitions --- */
        /* Smooth transition for sidebar enlarge */
        .sidebar > div { /* Target direct children of sidebar */
             transition: flex-basis 0.4s ease-in-out, opacity 0.4s ease-in-out;
        }
        .sidebar.enlarged-agent #background-work-container,
        .sidebar.enlarged-agent #interactive-chat-container,
        .sidebar.enlarged-bg #main-chat-container,
        .sidebar.enlarged-bg #interactive-chat-container,
        .sidebar.enlarged-interactive #main-chat-container,
        .sidebar.enlarged-interactive #background-work-container {
             flex-basis: 0 !important;
             opacity: 0;
             overflow: hidden; /* Hide content during transition */
        }

        /* Fade-in for table */
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        #database-table-container {
            animation: fadeIn 0.5s ease-in-out;
        }

        /* Background log collapse/expand transition */
        #background-header .spinner {
            /* Add spinner styles if needed, e.g., border color */
            border-top-color: var(--tcf-yellow);
            width: 14px; height: 14px; /* Smaller */
            margin-right: 8px;
        }
        #background-work-container .background-header {
             cursor: pointer; /* Indicate clickable header */
        }
        #background-log-area {
             transition: max-height 0.4s ease-in-out, padding 0.4s ease-in-out, opacity 0.3s ease-in-out;
             max-height: 300px; /* Adjust as needed for default visible height */
             overflow: hidden;
             opacity: 1;
        }
         #background-work-container.collapsed #background-log-area {
             max-height: 0;
             padding-top: 0;
             padding-bottom: 0;
             opacity: 0;
             border-top: none; /* Hide border when collapsed */
         }
         #background-work-container.collapsed {
             border-top: 1px solid var(--m6-border); /* Ensure top border remains */
         }
         #background-work-container:not(.collapsed) #background-log-area {
              border-top: 1px solid var(--m6-border); /* Show border when expanded */
         }

        /* Welcome Message Style */
        .welcome-message {
            padding: 15px;
            margin: 10px 8px; /* Match bubble margins */
            background-color: rgba(255, 199, 44, 0.1); /* Subtle yellow background */
            border: 1px solid var(--tcf-yellow);
            border-radius: 6px;
            color: var(--m6-text-primary);
            font-style: italic;
            text-align: center;
            font-size: 0.95em;
        }
        .welcome-message strong {
             color: var(--tcf-yellow);
             font-weight: bold;
        }


    </style>
</head>
<body>

    <div class="header">
        <div class="title-group">
            <h1>Top Chef France</h1>
            <p>Chef Explorer</p>
        </div>
        <div class="nav-links">
            <a href="/agent/history" class="agent-history-link">Agent History</a>
        </div>
        <div>
            <label for="season-filter">Season:</label>
            <select id="season-filter">
                <option value="">All Seasons</option>
            </select>
            <button id="view-toggle-button">Show Table</button>
        </div>
    </div>

    <div class="main-content">
        <!-- Primary View Container (Map or Table) -->
        <div class="primary-view-container">
            <div id="map"></div>
            <!-- Database Table Section (initially hidden) -->
            <div id="database-table-container">
                <h2>Chef Database</h2> <!-- Simplified Title -->
                <div id="table-placeholder">Loading database content...</div>
                <!-- Table structure remains the same, styling handled by CSS -->
                <div class="db-table-wrapper"> <!-- Added wrapper for potential future scrollbars -->
                     <table class="db-table">
                         <thead>
                             <tr>
                                 <th>ID</th>
                                 <th>Name</th>
                                 <th>Status</th>
                                 <th>Address</th>
                                 <th>Lat</th>
                                 <th>Lon</th>
                                 <th>Bio</th>
                                 <th>Season</th>
                                 <th>Last Updated</th>
                             </tr>
                         </thead>
                         <tbody id="chef-table">
                         </tbody>
                     </table>
                 </div>
            </div>
        </div>

        <!-- Sidebar Log -->
        <div class="sidebar">
            <!-- Main Chat Area -->
            <div id="main-chat-container">
                <div class="header-row"> <!-- Use class for consistent styling -->
                    <h2>StephAI travaille</h2>
                    <button class="enlarge-btn" id="enlarge-agent" title="Enlarge">&#x2922;</button> <!-- Expand icon -->
                </div>
                <div id="chat-log-area">
                    <div class="welcome-message">
                        <strong>Bienvenue sur le Chef Explorer !</strong><br>
                        DÃ©couvrez les candidats de Top Chef, leurs restaurants, et posez vos questions Ã  notre agent interactif ci-dessous. StephAI Botenberg ajoutera bientÃ´t ses propres commentaires ici !
                    </div>
                    <!-- Dynamic logs will be added here by JS -->
                </div>
            </div>
            <!-- Background Activity Area -->
            <div id="background-work-container" class="collapsed">
                <div class="background-header" id="background-header"> <!-- Use ID for JS, class for styling -->
                    <span>Background Activity</span> <!-- Simplified -->
                    <div>
                        <div class="spinner" id="loading-spinner" style="display: none;"></div> <!-- Hide initially -->
                        <span class="toggle-icon">+</span>
                    </div>
                    <button class="enlarge-btn" id="enlarge-bg" title="Enlarge">&#x2922;</button> <!-- Expand icon -->
                </div>
                <div id="background-log-area"></div>
            </div>
            <!-- Interactive Chat Area -->
            <div id="interactive-chat-container">
                <div id="interactive-chat-header"> <!-- Use ID for JS, class for styling -->
                    <span>Discutez avec StephAI</span> <!-- Simplified -->
                    <button class="enlarge-btn" id="enlarge-interactive" title="Enlarge">&#x2922;</button> <!-- Expand icon -->
                </div>
                <div id="interactive-chat-log-area"></div>
                <div id="interactive-chat-input-row">
                    <input type="text" id="interactive-chat-input" placeholder="Ask about chefs, seasons, locations..." autocomplete="off" />
                    <button id="interactive-chat-send">Send</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Embed JSON data safely -->
    <script id="chefs-data" type="application/json">
        {{ chefs_json|safe }} {# chefs_json is already a JSON string from backend, |safe prevents HTML escaping #}
    </script>

    <script>
        // --- Global Variables & Constants ---
        window.AGENT_NAME = {{ AGENT_NAME|tojson }}; // Define Agent Name as a window property to avoid redeclaration issues
        window.BACKGROUND_LOG_KEY = 'topchef_background_logs'; // Restore definition
        window.INTERACTIVE_LOG_KEY = 'topchef_interactive_logs'; // Restore definition
        window.MAIN_LOG_KEY = 'topchef_main_logs'; // Key for StephAI's main messages
        let backgroundLogArea = document.getElementById('background-log-area');
        let interactiveLogArea = document.getElementById('interactive-chat-log-area');
        let chatLogArea = document.getElementById('chat-log-area'); // Area for StephAI's main commentary
        let logCounter = 0;
        const maxLogEntries = 200; // Limit stored log entries

        // --- Map Initialization ---
        // Center roughly on France
        const map = L.map('map').setView([46.603354, 1.888334], 6);
        let markerLayer; // Declare markerLayer here

        // Add Tile Layer (OpenStreetMap)
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            maxZoom: 19,
            attribution: '&copy; <a href="http://www.openstreetmap.org/copyright">OpenStreetMap</a>'
        }).addTo(map);

        // Initialize marker layer and add to map
        markerLayer = L.layerGroup().addTo(map);

        // Function to add details to popup safely
        function addDetail(label, value) {
            // Use textContent for safety in popups too, unless HTML is needed
            const tempDiv = document.createElement('div');
            tempDiv.textContent = value !== null && value !== undefined ? String(value) : '';
            const escapedValue = tempDiv.innerHTML; // Let browser handle basic escaping

            if (value !== null && value !== undefined && String(value).trim() !== "") {
                return `<p><strong>${label}:</strong> ${escapedValue}</p>`;
            }
            return `<p><strong>${label}:</strong> <span class="missing-data">Missing</span></p>`;
        }

        // --- Chef Data Processing ---
        let chefsData = [];
        try {
            // Retrieve the JSON string from the dedicated script tag
            const jsonDataElement = document.getElementById('chefs-data');
            if (!jsonDataElement) {
                throw new Error("Could not find chefs-data script tag.");
            }
            const rawJsonData = jsonDataElement.textContent || jsonDataElement.innerText;
            // Parse the retrieved JSON string
            chefsData = JSON.parse(rawJsonData);

            if (!Array.isArray(chefsData)) {
                throw new Error("Parsed data is not a valid array.");
            }
        } catch (e) {
            console.error("Error processing chef JSON data:", e);
            const mapDiv = document.getElementById('map');
            if (mapDiv) {
                mapDiv.innerHTML = '<p style="color: red; padding: 20px;">Error loading chef data for the map.</p>';
            }
        }

        // --- Marker Creation ---
        if (Array.isArray(chefsData)) {
            chefsData.forEach(chef => {
                const lat = parseFloat(chef.latitude);
                const lon = parseFloat(chef.longitude);

                if (!isNaN(lat) && !isNaN(lon)) {
                    const marker = L.marker([lat, lon]).addTo(map);
                    let popupContent = `<h3>${chef.name || 'Unknown Chef'}</h3>`;
                    // Use the global addDetail function defined earlier

                    popupContent += addDetail('Status', chef.status);
                    popupContent += addDetail('Address', chef.restaurant_address);
                    popupContent += addDetail('Bio', chef.bio);

                    if (chef.image_url) {
                        if (String(chef.image_url).startsWith('http:') || String(chef.image_url).startsWith('https:')) {
                            popupContent += `<img src="${chef.image_url}" alt="${chef.name || 'Chef image'}" class="popup-image">`;
                        } else {
                            console.warn(`Skipping potentially unsafe image URL: ${chef.image_url}`);
                        }
                    }
                    marker.bindPopup(popupContent);
                }
            });
        } else {
            console.error("Chef data is not an array after processing:", chefsData);
        }

        // --- Log Viewer Logic ---
        const spinnerElement = document.getElementById('loading-spinner');
        let allLogs = []; // Maintain all logs in memory for filtering/searching if needed later

        // --- Functions ---

        // Helper to save logs to localStorage
        function saveLogsToStorage(key, logsArray) {
            try {
                localStorage.setItem(key, JSON.stringify(logsArray.slice(-maxLogEntries))); // Store only the last N logs
            } catch (e) {
                console.error(`Error saving logs to localStorage (${key}):`, e);
            }
        }

        // Helper to load logs from localStorage
        function loadLogsFromStorage(key) {
            try {
                const storedLogs = localStorage.getItem(key);
                return storedLogs ? JSON.parse(storedLogs) : [];
            } catch (e) {
                console.error(`Error loading logs from localStorage (${key}):`, e);
                return [];
            }
        }

        // Function to format structured log data (re-added)
        function formatLogData(log) {
            if (!log || !log.data) return 'Invalid log data';

            // Basic formatting - can be expanded
            if (typeof log.data === 'object') {
                // Handle different message formats
                if (log.data.content) {
                    return log.data.content; // Return content directly
                }
                if (log.data.message) {
                    return log.data.message; // Return message directly
                }
                // Handle tool call summaries
                if (log.data.count && log.data.calls) {
                    return `<em>Executing ${log.data.count} tool call(s)...</em>`;
                }
                // Example: Handle a specific known structure, e.g., tool call
                if (log.data.tool_name && log.data.arguments) {
                    return `Tool: ${log.data.tool_name} Args: ${JSON.stringify(log.data.arguments)}`;
                }
                
                // Try to find any string field that might contain a message
                for (const key in log.data) {
                    if (typeof log.data[key] === 'string' && log.data[key].length > 5) {
                        return log.data[key];
                    }
                }
                
                // Default for other objects
                try {
                    return `<pre>${JSON.stringify(log.data, null, 2)}</pre>`; // Pretty print JSON
                } catch {
                    return 'Could not format log data object.';
                }
            }
            // Fallback for non-objects (though addLogEntry handles strings separately)
            return String(log.data);
        }

        // Modified addLogEntry to handle both background and interactive logs, and save to storage
        function addLogEntry(log, areaElement, storageKey, logArray) {
            console.log('[addLogEntry] Received log:', log, 'Target Area:', areaElement ? areaElement.id : 'UNKNOWN'); // Debug: Log received data and target
            if (!log || !areaElement) {
                console.error('[addLogEntry] Error: Invalid log object or areaElement provided.', log, areaElement);
                return;
            }

            const logEntryElement = document.createElement('div');
            logEntryElement.classList.add('log-entry');

            let role = log.role || 'system'; // Default role
            let messageContent = '';
            let timestamp = log.timestamp ? new Date(log.timestamp * 1000).toLocaleTimeString() : new Date().toLocaleTimeString();

            // Determine class based on role
            if (role === AGENT_NAME) { // Use the agent's name
                logEntryElement.classList.add('log-entry-agent');
            } else if (role === 'user') {
                logEntryElement.classList.add('user-msg');
            } else if (role === 'system' || role === 'autonomous_agent') {
                logEntryElement.classList.add('log-entry-system');
            } else if (role === 'tool_executor') {
                logEntryElement.classList.add('log-entry-tool');
            } else {
                logEntryElement.classList.add('log-entry-info'); // Default/other
            }

            // Format message content based on log type or data structure
            if (typeof log.data === 'string') {
                messageContent = log.data;
            } else if (typeof log.data === 'object' && log.data !== null) {
                // Special handling for agent messages with various field structures
                if (log.role === AGENT_NAME) {
                    // Handle different message formats from the agent
                    if (log.data.content) {
                        messageContent = log.data.content; // Use content field directly
                    } else if (log.data.message) {
                        messageContent = log.data.message; // Use message field directly
                    } else if (log.data.count && log.data.calls) {
                        // For tool call summaries, format them nicely
                        messageContent = `<em>Executing ${log.data.count} tool call(s)...</em>`;
                        // Don't show the raw JSON for tool calls in the main chat
                    } else {
                        // Try to find any string field that might contain a message
                        let foundMessage = false;
                        for (const key in log.data) {
                            if (typeof log.data[key] === 'string' && log.data[key].length > 5) {
                                messageContent = log.data[key];
                                foundMessage = true;
                                break;
                            }
                        }
                        
                        if (!foundMessage) {
                            // If no suitable field found, use the formatter but hide in main chat
                            messageContent = "<em>Processing...</em>";
                        }
                    }
                } else {
                    messageContent = formatLogData(log); // Use existing formatter for non-agent messages
                }
            } else if (log.response) { // For interactive agent responses
                messageContent = log.response;
            } else if (log.error) { // For errors
                messageContent = `Error: ${log.error}`;
                logEntryElement.classList.add('log-entry-error');
            } else {
                messageContent = JSON.stringify(log); // Fallback
            }

            const timestampElement = document.createElement('span');
            timestampElement.classList.add('log-timestamp');
            timestampElement.textContent = `[${timestamp}]`;

            const roleElement = document.createElement('span');
            roleElement.classList.add('log-role');
            roleElement.textContent = role;

            const messageContentElement = document.createElement('span');
            messageContentElement.innerHTML = messageContent; // Use innerHTML for potential formatting from formatLogData

            logEntryElement.appendChild(timestampElement);
            logEntryElement.appendChild(roleElement);
            logEntryElement.appendChild(messageContentElement);

            console.log('[addLogEntry] Created element:', logEntryElement); // Debug: Log the created element

            try {
                areaElement.appendChild(logEntryElement);
                console.log('[addLogEntry] Successfully appended element to:', areaElement.id); // Debug: Confirm append
            } catch (error) {
                console.error('[addLogEntry] FAILED to append element to:', areaElement.id, error); // Debug: Log append failure
                 // Optionally display an error in the log area itself
                 const errorElement = document.createElement('div');
                 errorElement.className = 'log-entry log-entry-error';
                 errorElement.textContent = `[UI Error] Failed to display log entry. See console.`;
                 areaElement.appendChild(errorElement);
            }

            // Auto-scroll to the bottom
            areaElement.scrollTop = areaElement.scrollHeight;
            // Add to the in-memory array and save to storage
            logArray.push(log); // Store the original log object
            saveLogsToStorage(storageKey, logArray);

            // Remove oldest entries if exceeding max
            while (areaElement.children.length > maxLogEntries) {
                areaElement.removeChild(areaElement.firstChild);
            }
            // Also trim the in-memory array if needed (though saveLogs already slices)
            if (logArray.length > maxLogEntries * 1.1) { // Keep a bit more in memory just in case
                 logArray.splice(0, logArray.length - maxLogEntries);
            }

            // Hide spinner after first message (if it exists)
            if (spinnerElement) {
                spinnerElement.style.display = 'none';
            }
        }

        // Load initial logs from storage
        let backgroundLogs = loadLogsFromStorage(BACKGROUND_LOG_KEY);
        backgroundLogs.forEach(log => addLogEntry(log, backgroundLogArea, BACKGROUND_LOG_KEY, backgroundLogs));

        let mainLogs = loadLogsFromStorage(MAIN_LOG_KEY); // Load main chat logs
        mainLogs.forEach(log => addLogEntry(log, chatLogArea, MAIN_LOG_KEY, mainLogs)); // Populate main chat area

        // Interactive logs handled by interactive_chat.js

        // --- SSE Connection (Background Logs) ---
        const eventSource = new EventSource("/stream_logs");

        eventSource.onopen = function() {
            console.log("SSE connection opened for background logs.");
            // Optional: add a visual indicator
        };

        eventSource.onmessage = function(event) {
            // Ignore empty messages or potential keep-alive pings
            if (!event.data || !event.data.trim()) {
                // console.debug("SSE: Received empty message.");
                return;
            }
            // Check if data looks like JSON before parsing
            const potentialJson = event.data.trim();
            if (potentialJson.startsWith('{') || potentialJson.startsWith('[')) {
                try {
                    const logData = JSON.parse(potentialJson);
                    if (logData.type === 'stream_error') {
                        console.error('SSE Stream Error:', logData.data.error);
                        addLogEntry({ role: 'system', data: `Stream Error: ${logData.data.error}`, timestamp: Date.now()/1000, type: 'error' }, backgroundLogArea, BACKGROUND_LOG_KEY, backgroundLogs);
                    } else if (logData.type) { // Basic check for a valid log structure
                        // Route based on role
                        if (logData.role === AGENT_NAME) {
                             // Send Agent's main messages to the main chat area
                             console.log(`Routing log from ${AGENT_NAME} to main chat area.`);
                             addLogEntry(logData, chatLogArea, MAIN_LOG_KEY, mainLogs);
                        } else {
                             // Send system/tool logs to the background area
                             console.log(`Routing log from ${logData.role || 'unknown'} to background area.`);
                             addLogEntry(logData, backgroundLogArea, BACKGROUND_LOG_KEY, backgroundLogs);
                        }
                    } else {
                         console.warn("SSE: Received JSON data without 'type' field: ", logData);
                    }
                } catch (e) {
                    console.error("Error parsing seemingly valid JSON from SSE:", event.data, e);
                     addLogEntry({ type: 'db_stream_error', data: `Failed processing log data: ${e.message}`, timestamp: Date.now() / 1000, role: 'system' }, backgroundLogArea, BACKGROUND_LOG_KEY, backgroundLogs);
                }
            } else {
                 // Silently ignore non-JSON messages (likely keep-alives)
                 console.debug("SSE: Ignored non-JSON message: ", event.data);
            }
        };

        eventSource.onerror = function(err) {
            console.error("SSE Error occurred:", err);
            addLogEntry({ type: 'db_stream_error', data: 'Log stream connection error. Trying to reconnect...', timestamp: Date.now() / 1000, role: 'system' }, backgroundLogArea, BACKGROUND_LOG_KEY, backgroundLogs);
            // EventSource automatically attempts to reconnect.
            // Consider closing after too many errors: eventSource.close();
        };

        // --- Restored Database Table, Filtering, View Toggle, and DB Update Logic ---
        let tableLoaded = false; // Tracks initial load
        const tablePlaceholder = document.getElementById('table-placeholder');
        const tableContainer = document.getElementById('database-table-container'); // Get container reference

        async function refreshTableData(season = null) {
            console.log("Refreshing table data...", season ? `for season ${season}` : '');
            tablePlaceholder.textContent = 'Refreshing database content...'; // Update placeholder text
            tablePlaceholder.style.color = '#666'; // Reset color
            tableLoaded = false; // Reset flag to allow reload display logic

            // Clear existing table if it exists within the wrapper
            const existingWrapper = tablePlaceholder.querySelector('.db-table-wrapper');
            if (existingWrapper) {
                tablePlaceholder.removeChild(existingWrapper);
            }
            // Fetch potentially filtered data
            const chefs = await fetchChefs(season);
            await loadAndDisplayTable(chefs); // Call the main loading function with fetched data
        }

        async function loadAndDisplayTable(chefs) {
            try {
                // Data is now passed in, no need to fetch here
                if (!Array.isArray(chefs)) {
                    throw new Error("Invalid chef data provided to loadAndDisplayTable.");
                }

                if (chefs.length === 0) {
                    tablePlaceholder.textContent = 'No chef data found matching the criteria.';
                    // Clear any previous table
                     const existingWrapper = tablePlaceholder.querySelector('.db-table-wrapper');
                    if (existingWrapper) {
                        tablePlaceholder.removeChild(existingWrapper);
                    }
                    return;
                }

                const columns = [
                    { key: 'id', header: 'ID' },
                    { key: 'name', header: 'Name' },
                    { key: 'status', header: 'Status' },
                    { key: 'restaurant_address', header: 'Address' },
                    { key: 'latitude', header: 'Lat' },
                    { key: 'longitude', header: 'Lon' },
                    { key: 'bio', header: 'Bio', className: 'col-bio' },
                    { key: 'season', header: 'Season' },
                    { key: 'last_updated', header: 'Last Updated' },
                ];

                const tableWrapper = document.createElement('div');
                tableWrapper.classList.add('db-table-wrapper');
                const table = document.createElement('table');
                table.classList.add('db-table');
                const thead = document.createElement('thead');
                const tbody = document.createElement('tbody');
                const headerRow = document.createElement('tr');

                columns.forEach(col => {
                    const th = document.createElement('th');
                    th.textContent = col.header;
                    if (col.className) {
                        th.classList.add(col.className);
                    }
                    headerRow.appendChild(th);
                });
                thead.appendChild(headerRow);

                chefs.forEach(chef => {
                    const row = document.createElement('tr');
                    columns.forEach(col => {
                        const td = document.createElement('td');
                        let value = chef[col.key];

                        // Format date nicely
                        if (col.key === 'last_updated' && value) {
                            try {
                                value = new Date(value).toLocaleString();
                            } catch { /* leave as is */ }
                        }

                        // Use textContent for safety
                        td.textContent = (value === null || typeof value === 'undefined') ? '' : String(value);

                        if (col.className) {
                            td.classList.add(col.className);
                            if (col.className === 'col-bio') {
                                td.setAttribute('title', (value === null || typeof value === 'undefined') ? '' : String(value));
                            }
                        }
                        row.appendChild(td);
                    });
                    tbody.appendChild(row);
                });

                table.appendChild(thead);
                table.appendChild(tbody);
                tableWrapper.appendChild(table);

                tablePlaceholder.innerHTML = ''; // Clear placeholder text/spinner
                tablePlaceholder.appendChild(tableWrapper);
                tableLoaded = true; // Mark as loaded after successful display

            } catch (error) {
                console.error('Error loading or displaying database table:', error);
                tablePlaceholder.textContent = `Error loading table data: ${error.message}. Check console for details.`;
                tablePlaceholder.style.color = 'red';
            }
        }

        // --- View Toggle Logic ---
        const toggleButton = document.getElementById('view-toggle-button');
        const mapContainer = document.getElementById('map');
        // tableContainer is already defined above
        let currentView = 'map'; // Assume map is default

        toggleButton.addEventListener('click', async () => {
            if (currentView === 'map') {
                // Switch to Table View
                mapContainer.style.display = 'none';
                tableContainer.style.display = 'flex'; // Use flex now
                toggleButton.textContent = 'Show Map';
                currentView = 'table';
                // Load table data based on the *current* season filter
                const selectedSeason = document.getElementById('season-filter').value;
                const chefsToDisplay = filterChefsBySeason(allChefs, selectedSeason);
                await loadAndDisplayTable(chefsToDisplay);
            } else {
                // Switch to Map View
                tableContainer.style.display = 'none';
                mapContainer.style.display = 'block';
                toggleButton.textContent = 'Show Table';
                currentView = 'map';
                // Update map markers based on the current season filter
                const selectedSeason = document.getElementById('season-filter').value;
                const chefsToDisplay = filterChefsBySeason(allChefs, selectedSeason);
                updateMapMarkers(chefsToDisplay); // Assumes updateMapMarkers exists and handles clearing/adding
                setTimeout(() => {
                    map.invalidateSize(); // Ensure map resizes correctly
                }, 10);
            }
        });

        // --- SSE Connection for Database Updates ---
        const dbUpdateEventSource = new EventSource("/stream_db_updates");

        dbUpdateEventSource.onopen = function() {
            console.log("DB Update SSE Connected");
        };

        dbUpdateEventSource.onmessage = async function(event) {
            try {
                const updateSignal = JSON.parse(event.data);
                console.log("Received DB update signal:", updateSignal);
                if (updateSignal.event === "update") {
                    // 1. Re-fetch all data to update the global 'allChefs' array
                    allChefs = await fetchChefs();
                    console.log("Refetched all chef data after update signal.");
                    // 2. Get current filter
                    const selectedSeason = document.getElementById('season-filter').value;
                    // 3. Filter the newly fetched data
                    const chefsToDisplay = filterChefsBySeason(allChefs, selectedSeason);
                    // 4. Update the currently active view
                    if (currentView === 'table') {
                        console.log("Refreshing table view after update signal.");
                        await loadAndDisplayTable(chefsToDisplay);
                    } else {
                        console.log("Refreshing map view after update signal.");
                        updateMapMarkers(chefsToDisplay); // Update map markers
                    }
                    // 5. Repopulate season filter in case seasons changed
                    populateSeasonFilter(allChefs);
                }
            } catch (e) {
                console.error("Failed to parse DB Update SSE data or refresh view:", event.data, e);
                addLogEntry({ type: 'db_stream_error', data: `Failed processing DB update signal: ${e.message}`, timestamp: Date.now() / 1000, role: 'system' }, backgroundLogArea, BACKGROUND_LOG_KEY, backgroundLogs);
            }
        };

        dbUpdateEventSource.onerror = function(err) {
            console.error("DB Update EventSource failed:", err);
            addLogEntry({ type: 'db_stream_error', data: 'DB Update stream connection error. Check console.', timestamp: Date.now() / 1000, role: 'system' }, backgroundLogArea, BACKGROUND_LOG_KEY, backgroundLogs);
        };

        // --- Table and Map Data Loading / Filtering ---
        let allChefs = []; // Holds all chef data fetched initially or after update

        // Populate the season filter dropdown based on chef data
        function populateSeasonFilter(chefs) {
            const seasonSet = new Set();
            chefs.forEach(chef => {
                if (chef.season !== undefined && chef.season !== null) {
                    seasonSet.add(chef.season);
                }
            });
            const seasonFilter = document.getElementById('season-filter');
            const currentValue = seasonFilter.value; // Preserve selection if possible
            // Remove old options except 'All'
            seasonFilter.querySelectorAll('option:not([value=""])').forEach(opt => opt.remove());
            Array.from(seasonSet).sort((a, b) => a - b).forEach(season => {
                const opt = document.createElement('option');
                opt.value = season;
                opt.textContent = `Season ${season}`;
                seasonFilter.appendChild(opt);
            });
            // Try to restore previous selection, default to 'All' if it's gone
             if (Array.from(seasonFilter.options).some(opt => opt.value === currentValue)) {
                 seasonFilter.value = currentValue;
             } else {
                 seasonFilter.value = ""; // Default to 'All'
             }
        }

        // Filter chefs by selected season (accepts string or number for season)
        function filterChefsBySeason(chefs, season) {
            if (season === null || season === "" || season === undefined) return chefs; // Handle 'All Seasons'
            const seasonNum = parseInt(season, 10);
            return chefs.filter(chef => chef.season === seasonNum);
        }

        // Update Map Markers (Moved definition here)
        function updateMapMarkers(chefsToDisplay) {
            markerLayer.clearLayers(); // Clear existing markers
            chefsToDisplay.forEach(chef => {
                if (chef.latitude != null && chef.longitude != null) {
                    try {
                        const lat = parseFloat(chef.latitude);
                        const lon = parseFloat(chef.longitude);
                        if (!isNaN(lat) && !isNaN(lon)) {
                            const marker = L.marker([lat, lon]);

                            // Build popup content using helper
                            let popupContent = `<strong>${chef.name || 'Unknown Chef'}</strong><br>`;
                            popupContent += addDetail('Season', chef.season);
                            popupContent += addDetail('Status', chef.status);
                            popupContent += addDetail('Address', chef.restaurant_address);
                            popupContent += addDetail('Bio', chef.bio);

                            marker.bindPopup(popupContent);
                            markerLayer.addLayer(marker);
                        }
                    } catch (e) {
                        console.warn(`Skipping marker for chef ${chef.id} due to invalid coordinates`, e);
                    }
                }
            });
        }

        // Listen for season filter changes
        document.getElementById('season-filter').addEventListener('change', async function() {
            const selectedSeason = this.value;
            // Filter the existing 'allChefs' data
            const chefsToDisplay = filterChefsBySeason(allChefs, selectedSeason);
            // Update the currently active view
            if (currentView === 'table') {
                await loadAndDisplayTable(chefsToDisplay);
            } else {
                updateMapMarkers(chefsToDisplay);
            }
        });

        // Enlarging chat windows logic
        const sidebar = document.querySelector('.sidebar');
        const enlargeAgent = document.getElementById('enlarge-agent');
        const enlargeBg = document.getElementById('enlarge-bg');
        const enlargeInteractive = document.getElementById('enlarge-interactive');
        function toggleEnlarge(which) {
            if (!sidebar) return; // Safety check
            const targetClass = 'enlarged-' + which;
            if (sidebar.classList.contains(targetClass)) {
                 sidebar.classList.remove(targetClass);
            } else {
                sidebar.classList.remove('enlarged-agent', 'enlarged-bg', 'enlarged-interactive'); // Remove any existing enlarge class
                sidebar.classList.add(targetClass);
            }
        }
        if (enlargeAgent) enlargeAgent.addEventListener('click', function() { toggleEnlarge('agent'); });
        if (enlargeBg) enlargeBg.addEventListener('click', function() { toggleEnlarge('bg'); });
        if (enlargeInteractive) enlargeInteractive.addEventListener('click', function() { toggleEnlarge('interactive'); });

        // Fetch chefs from backend with optional season param
        async function fetchChefs(season = null) {
            let url = '/api/chefs';
            // Only add season param if it's a specific season (not empty string for 'All')
            if (season !== null && season !== "") {
                 url += `?season=${season}`;
            }
            try {
                const response = await fetch(url);
                 if (!response.ok) {
                     throw new Error(`API fetch error! status: ${response.status}`);
                 }
                 return await response.json();
            } catch (error) {
                 console.error('Failed to fetch chefs:', error);
                 tablePlaceholder.textContent = `Error fetching chef data: ${error.message}.`;
                 tablePlaceholder.style.color = 'red';
                 return []; // Return empty array on error
            }
        }

        // --- Background Log Collapse/Expand Logic (Now follows restored code) ---
        const backgroundHeader = document.getElementById('background-header');
        const backgroundContainer = document.getElementById('background-work-container');
        const toggleIcon = backgroundHeader.querySelector('.toggle-icon');

        backgroundHeader.addEventListener('click', () => {
            backgroundContainer.classList.toggle('collapsed');
            if (backgroundContainer.classList.contains('collapsed')) {
                toggleIcon.textContent = '+';
            } else {
                toggleIcon.textContent = '-';
                // Scroll to bottom when expanding
                backgroundLogArea.scrollTop = backgroundLogArea.scrollHeight;
            }
        });

        // --- Initial Load --- Execute async function (Modified)
        (async function() {
            allChefs = await fetchChefs(); // Fetch all initially
            populateSeasonFilter(allChefs); // Populate filter based on fetched data
            updateMapMarkers(allChefs); // Initial map display (all seasons)
            // Initial table load ONLY if table view is the default/active on load
            if (currentView === 'table') { // Check currentView state determined by toggle logic
                 await loadAndDisplayTable(allChefs);
            }
            // Ensure spinner is hidden after initial load attempts
            if (spinnerElement) {
                spinnerElement.style.display = 'none';
            }
        })();

        // Setup interactive chat
        (function setupInteractiveChat() {
            const inputElement = document.getElementById('interactive-chat-input');
            const sendButton = document.getElementById('interactive-chat-send');
            const logArea = document.getElementById('interactive-chat-log-area');
            const storageKey = 'interactiveLogs';
            let logs = []; // Use a local array for interactive logs

            const sendMessage = async () => {
                const message = inputElement.value.trim();
                if (message === '') {
                    return; // Don't send empty messages
                }

                // Add user message to log
                const userLog = { message: message, source: 'user', timestamp: new Date().toISOString() };
                addLogEntry(userLog, logArea, storageKey, logs);
                inputElement.value = ''; // Clear input field

                // Add thinking indicator
                const thinkingLog = { message: 'Thinking...', source: 'agent', timestamp: new Date().toISOString(), type: 'thinking' };
                const thinkingElement = addLogEntry(thinkingLog, logArea, storageKey, logs, true); // Add temporarily

                try {
                    const response = await fetch('/ask_agent', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({ query: message }),
                    });

                    // Remove thinking indicator
                    if (thinkingElement) {
                        logArea.removeChild(thinkingElement);
                        // Also remove from the logs array if it was added temporarily
                        logs.pop(); 
                        // Note: This assumes thinking log was the last one added temporarily. 
                        // A more robust approach might involve IDs if needed.
                    }

                    if (!response.ok) {
                        const errorData = await response.json().catch(() => ({ error: 'Failed to parse error response.' }));
                        throw new Error(errorData.error || `HTTP error! status: ${response.status}`);
                    }

                    const data = await response.json();

                    // Add agent response to log
                    const agentLog = { message: data.response, source: 'agent', timestamp: new Date().toISOString() };
                    addLogEntry(agentLog, logArea, storageKey, logs);

                } catch (error) {
                     // Remove thinking indicator even if there's an error
                    if (thinkingElement && thinkingElement.parentNode === logArea) {
                        logArea.removeChild(thinkingElement);
                         logs.pop(); // Remove from array as well
                    }
                    console.error('Error sending message:', error);
                    const errorLog = { message: `Error: ${error.message}`, source: 'system', type: 'error', timestamp: new Date().toISOString() };
                    addLogEntry(errorLog, logArea, storageKey, logs);
                }
            };

            sendButton.addEventListener('click', sendMessage);

            inputElement.addEventListener('keypress', (event) => {
                if (event.key === 'Enter') {
                    event.preventDefault(); // Prevent default form submission/newline
                    sendMessage();
                }
            });
        })();
    </script>
    <!-- Load the interactive chat JavaScript -->
    <script>
        // Make necessary functions/variables global or pass them carefully
        window.addLogEntry = addLogEntry;
        window.interactiveLogArea = interactiveLogArea;
        window.INTERACTIVE_LOG_KEY = INTERACTIVE_LOG_KEY;
        window.interactiveLogs = interactiveLogs; // Pass the initially loaded logs
        window.AGENT_NAME = "{{ AGENT_NAME }}"; // Use the AGENT_NAME passed from Flask
    </script>
    <script src="{{ url_for('static', filename='interactive_chat.js') }}"></script>
</body>
</html>
