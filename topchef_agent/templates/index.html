<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Top Chef France Map & Agent</title>
    <!-- Leaflet CSS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
          integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
          crossorigin=""/>
    <!-- Leaflet JavaScript -->
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
            integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
            crossorigin=""></script>

    <style>
        html, body {
            height: 100%;
            margin: 0;
            padding: 0;
            font-family: sans-serif;
            background-color: #f4f4f4;
            display: flex;
            flex-direction: column; /* Stack elements vertically */
        }

        .header {
            padding: 10px 20px;
            background-color: #333;
            color: white;
            flex-shrink: 0; /* Prevent header from shrinking */
            display: flex; /* Use flexbox for alignment */
            justify-content: space-between; /* Space out title and button */
            align-items: center; /* Vertically align items */
        }

        .header .title-group h1 { /* Target h1 within a group */
             margin: 0;
            font-size: 1.5em;
        }
        .header .title-group p { /* Target p within a group */
             margin: 5px 0 0;
             font-size: 0.9em;
             color: #ccc;
        }

        /* Toggle Button Style */
        #view-toggle-button {
            padding: 8px 15px;
            font-size: 0.9em;
            cursor: pointer;
            background-color: #555;
            color: white;
            border: none;
            border-radius: 4px;
            transition: background-color 0.2s;
        }
        #view-toggle-button:hover {
            background-color: #777;
        }


        .main-content {
            display: flex;
            flex-grow: 1; /* Allow main content to fill space */
            overflow: hidden; /* Prevent overflow issues */
            padding: 10px;
            gap: 10px; /* Space between primary view and log */
        }

        /* Container for the switchable view (Map or Table) */
        .primary-view-container {
            height: 100%;
            width: 65%; /* Take up the main area */
            position: relative; /* Needed for absolute positioning of children if required, or just structure */
            border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            background-color: #fff; /* Background for the container */
            overflow: hidden; /* Hide overflow from children */
        }

        #map {
            height: 100%;
            width: 100%; /* Fill the primary container */
            /* Removed border-radius and shadow as they are on the container now */
        }

        .sidebar {
            height: 100%;
            width: 35%; /* Remaining width for the log */
            display: flex;
            flex-direction: column;
            background-color: #fff;
            border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            overflow: hidden; /* Prevent scrollbar on the main sidebar div */
        }

        /* Styling for the two log sections */
        #main-chat-container, #background-work-container {
            display: flex;
            flex-direction: column;
            overflow: hidden; /* Prevent inner containers from overflowing sidebar */
        }

        #main-chat-container {
            flex-basis: 60%; /* Adjust initial height ratio as needed */
            border-bottom: 2px solid #ccc; /* Separator */
        }

        #background-work-container {
            flex-basis: 40%;
        }

        /* Headers for both sections */
        .sidebar h2, .background-header {
            margin: 0;
            padding: 10px 15px; /* Slightly reduced padding */
            background-color: #e2e2e2;
            font-size: 1.1em; /* Slightly smaller */
            color: #333;
            border-bottom: 1px solid #ddd;
            flex-shrink: 0;
            display: flex; /* Use flex for alignment */
            justify-content: space-between; /* Space out title and icons */
            align-items: center;
        }

        .background-header {
            cursor: pointer; /* Indicate clickable */
            user-select: none; /* Prevent text selection */
        }
        .background-header:hover {
            background-color: #d8d8d8;
        }

        /* Simple CSS Spinner */
        .spinner {
            border: 3px solid #f3f3f3; /* Light grey */
            border-top: 3px solid #555; /* Dark grey */
            border-radius: 50%;
            width: 16px; /* Size */
            height: 16px;
            animation: spin 1s linear infinite;
            display: none; /* Hidden by default */
            margin-left: 10px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Toggle icon (simple +/-) */
        .toggle-icon {
            font-weight: bold;
            margin-left: 10px;
        }

        /* Log container styling */
        #chat-log-area, #background-log-area {
            flex-grow: 1; /* Allow log areas to fill their container */
            padding: 10px; /* Reduced padding */
            background-color: #282c34; /* Dark background */
            color: #abb2bf; /* Light text */
            overflow-y: scroll; /* Enable scrolling */
            font-family: 'Courier New', Courier, monospace;
            font-size: 0.8em; /* Slightly smaller font */
            line-height: 1.3;
            white-space: pre-wrap; /* Preserve whitespace and wrap lines */
        }

        /* Hide background log area when collapsed */
        #background-work-container.collapsed #background-log-area {
            display: none;
            /* Alternative: max-height transition
            max-height: 0;
            padding-top: 0;
            padding-bottom: 0;
            overflow: hidden;
            transition: max-height 0.3s ease-out, padding 0.3s ease-out;
            */
        }
        /* Style when expanded (for transition alternative)
        #background-work-container #background-log-area {
             max-height: 500px; // Or a large enough value
             transition: max-height 0.3s ease-in, padding 0.3s ease-in;
        }
        */

        .sidebar h2 {
            margin: 0;
            padding: 15px;
            background-color: #e2e2e2;
            font-size: 1.2em;
            color: #333;
            border-bottom: 1px solid #ddd;
        }

        /* Specific log area styling */
        #chat-log-area {
             background-color: #f8f9fa; /* Lighter background for chat */
             color: #333; /* Darker text for chat */
             font-family: sans-serif; /* More readable font for chat */
             font-size: 0.9em;
        }

        #background-log-area {
             background-color: #282c34; /* Dark background for technical logs */
            color: #abb2bf; /* Light text for technical logs */
            /* Inherits font, size, line-height from shared rule */
        }


        /* Log entry styling */
        .log-entry {
            margin-bottom: 6px; /* Reduced margin */
            padding-bottom: 6px;
            border-bottom: 1px solid #444; /* Default border for dark theme */
        }
        .log-entry:last-child { border-bottom: none; }

        /* Specific border for light chat area */
        #chat-log-area .log-entry {
            border-bottom: 1px solid #eee;
        }

        .log-timestamp { color: #61afef; margin-right: 8px; font-size: 0.9em; }
        #chat-log-area .log-timestamp { color: #6c757d; } /* Grey timestamp in chat */

        .log-role { font-weight: bold; margin-right: 8px; }
        /* Role-based coloring (can be applied in JS) */
        .role-StephAI { color: #d19a66; } /* Orange/Brown for StephAI */
        .role-scheduler { color: #61afef; } /* Blue for scheduler/user */
        .role-tool_executor { color: #98c379; } /* Green for tools */
        .role-system { color: #c678dd; } /* Purple for system */

        .log-data { display: block; margin-top: 3px; margin-left: 15px; white-space: pre-wrap; }

        /* Specific styling for chat messages */
         #chat-log-area .log-entry .log-data {
             margin-left: 0; /* No indent for main chat data */
         }
         #chat-log-area .log-entry.log-entry-stephai { /* Style agent messages */
             background-color: #e9ecef;
             padding: 8px;
             border-radius: 5px;
             margin-left: 20px; /* Indent agent messages */
             border-bottom: none;
         }
         #chat-log-area .log-entry.log-entry-scheduler { /* Style user/scheduler messages */
             background-color: #d1e7dd;
             padding: 8px;
             border-radius: 5px;
             margin-right: 20px; /* Align user messages to the right (or keep left) */
             border-bottom: none;
         }


        /* Type-based coloring (mostly for background log) */
        .log-type-error { color: #e06c75; font-weight: bold; } /* Red for errors */
        #background-log-area .log-entry.log-type-error { background-color: rgba(224, 108, 117, 0.1); }

        .log-type-tool_result, .log-type-tool_start { color: #98c379; } /* Green */
        .log-type-llm_tool_request { color: #56b6c2; } /* Cyan */
        .log-type-llm_request { color: #c678dd; } /* Purple */
        .log-type-cycle_info { color: #61afef; } /* Blue */
        .log-type-cycle_start, .log-type-cycle_end { color: #e5c07b; } /* Yellow */

        /* Leaflet Popup Styling */
        .leaflet-popup-content-wrapper {
            background: #fff;
            border-radius: 8px;
            box-shadow: 0 3px 14px rgba(0,0,0,0.4);
        }
        .leaflet-popup-content {
            margin: 15px;
            line-height: 1.5;
            font-size: 0.95em;
            max-height: 250px; /* Limit popup height */
            overflow-y: auto; /* Allow scrolling within popup */
        }
        .leaflet-popup-content h3 {
            margin: 0 0 10px 0;
            padding-bottom: 5px;
            border-bottom: 1px solid #eee;
            font-size: 1.2em;
            color: #333;
        }
        .leaflet-popup-content p {
            margin: 5px 0;
        }
        .leaflet-popup-content strong {
            color: #555;
        }
        .leaflet-popup-tip-container {
            display: none; /* Optional: hide the small triangle tip */
        }
        .popup-image {
            max-width: 100%;
            height: auto;
            border-radius: 4px;
            margin-top: 10px;
        }
        .missing-data {
            color: #b94a48;
            font-style: italic;
        }


        /* --- Table Styling (no changes needed here) --- */
        #database-table-container {
            height: 100%; /* Fill the primary container */
            width: 100%;
            padding: 15px;
            overflow: auto; /* Allow scrolling within the container */
            display: none; /* Initially hidden */
            box-sizing: border-box; /* Include padding in height/width */
            flex-direction: column; /* Stack h2 and table wrapper */
        }
        #database-table-container h2 {
             margin: 0 0 15px 0;
             padding-bottom: 10px;
             border-bottom: 1px solid #ddd;
             font-size: 1.3em;
             color: #333;
             flex-shrink: 0; /* Prevent shrinking when content overflows */
        }
        #table-placeholder {
             padding: 20px;
             text-align: center;
             color: #666;
             flex-grow: 1; /* Allow placeholder to fill space if table wrapper is empty */
        }
        .db-table-wrapper {
             overflow-y: auto; /* Enable vertical scroll for the table content */
             flex-grow: 1; /* Allow wrapper to fill remaining space */
        }
        .db-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.9em;
        }
        .db-table th, .db-table td {
            border: 1px solid #ddd;
            padding: 8px 12px;
            text-align: left;
            vertical-align: top; /* Align content to the top */
            white-space: normal; /* Allow text wrapping */
            word-break: break-word; /* Break long words if necessary */
        }
        .db-table th {
            background-color: #e9e9e9;
            font-weight: bold;
            position: sticky; /* Make header sticky */
            top: 0; /* Stick to the top */
            z-index: 1; /* Ensure header is above scrolling content */
        }
        .db-table tr:nth-child(even) {
            background-color: #f9f9f9;
        }
        .db-table tr:hover {
            background-color: #f1f1f1;
        }
        .db-table .col-bio, .db-table .col-perplexity {
             max-width: 300px; /* Example max width */
             overflow: hidden;
             text-overflow: ellipsis; /* Add ellipsis for overflow */
        }


    </style>
</head>
<body>

    <div class="header">
        <div class="title-group">
            <h1>Top Chef France Map & StephAI</h1>
            <p>Explore restaurant locations and follow StephAI's database updates.</p>
        </div>
        <button id="view-toggle-button">Show Table</button>
    </div>

    <div class="main-content">
        <!-- Primary View Container (Map or Table) -->
        <div class="primary-view-container">
            <div id="map"></div>
            <!-- Database Table Section (initially hidden) -->
            <div id="database-table-container">
                <h2>Chef Database View</h2>
                <div id="table-placeholder">Loading database content...</div>
                <!-- Table will be generated here by JavaScript -->
            </div>
        </div>

        <!-- Sidebar Log -->
        <!-- Sidebar Log -->
        <div class="sidebar">
            <!-- Main Chat Area -->
            <div id="main-chat-container">
                <h2>StephAI Chat</h2>
                <div id="chat-log-area">
                    Waiting for StephAI...
                </div>
            </div>
            <!-- Background Activity Area (Collapsible) -->
            <div id="background-work-container" class="collapsed">
                 <div class="background-header" id="background-header">
                     <span>Background Activity</span>
                     <div> <!-- Container for spinner and toggle icon -->
                         <div class="spinner" id="loading-spinner"></div>
                         <span class="toggle-icon">+</span>
                     </div>
                 </div>
                 <div id="background-log-area">
                     <!-- Background logs will appear here -->
                 </div>
            </div>
        </div>
    </div>


    <!-- Embed JSON data safely -->
    <script id="chefs-data" type="application/json">
        {{ chefs_json|safe }} {# chefs_json is already a JSON string from backend, |safe prevents HTML escaping #}
    </script>

    <script>
        // --- Map Initialization ---
        // Center roughly on France
        const map = L.map('map').setView([46.603354, 1.888334], 6);

        // Add OpenStreetMap tile layer
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            maxZoom: 19,
            attribution: '&copy; <a href="http://www.openstreetmap.org/copyright">OpenStreetMap</a>'
        }).addTo(map);

        // --- Chef Data Processing ---
        let chefsData = [];
        try {
            // Retrieve the JSON string from the dedicated script tag
            const jsonDataElement = document.getElementById('chefs-data');
            if (!jsonDataElement) {
                throw new Error("Could not find chefs-data script tag.");
            }
            const rawJsonData = jsonDataElement.textContent || jsonDataElement.innerText;
            // Parse the retrieved JSON string
            chefsData = JSON.parse(rawJsonData);

            if (!Array.isArray(chefsData)) {
                 throw new Error("Parsed data is not a valid array.");
            }
        } catch (e) {
            console.error("Error processing chef JSON data:", e);
            const mapDiv = document.getElementById('map');
            if (mapDiv) {
                 mapDiv.innerHTML = '<p style="color: red; padding: 20px;">Error loading chef data for the map.</p>';
            }
        }

        // --- Marker Creation ---
        if (Array.isArray(chefsData)) {
            chefsData.forEach(chef => {
                const lat = parseFloat(chef.latitude);
                const lon = parseFloat(chef.longitude);

                if (!isNaN(lat) && !isNaN(lon)) {
                    const marker = L.marker([lat, lon]).addTo(map);
                    let popupContent = `<h3>${chef.name || 'Unknown Chef'}</h3>`;
                    const addDetail = (label, value) => {
                        // Use textContent for safety in popups too, unless HTML is needed
                        const tempDiv = document.createElement('div');
                        tempDiv.textContent = value !== null && value !== undefined ? String(value) : '';
                        const escapedValue = tempDiv.innerHTML; // Let browser handle basic escaping

                        if (value !== null && value !== undefined && String(value).trim() !== "") {
                            return `<p><strong>${label}:</strong> ${escapedValue}</p>`;
                        }
                        return `<p><strong>${label}:</strong> <span class="missing-data">Missing</span></p>`;
                    };

                    popupContent += addDetail('Status', chef.status);
                    popupContent += addDetail('Address', chef.restaurant_address);
                    popupContent += addDetail('Bio', chef.bio);

                    if (chef.image_url) {
                        if (String(chef.image_url).startsWith('http:') || String(chef.image_url).startsWith('https:')) {
                             popupContent += `<img src="${chef.image_url}" alt="${chef.name || 'Chef image'}" class="popup-image">`;
                        } else {
                             console.warn(`Skipping potentially unsafe image URL: ${chef.image_url}`);
                        }
                    }
                    marker.bindPopup(popupContent);
                }
            });
        } else {
             console.error("Chef data is not an array after processing:", chefsData);
        }


        // --- Log Viewer Logic ---
        const chatLogArea = document.getElementById('chat-log-area');
        const backgroundLogArea = document.getElementById('background-log-area');
        const loadingSpinner = document.getElementById('loading-spinner');
        let backgroundTaskCount = 0; // Counter for active background tasks

        // Accepts the full log object passed to it
        function formatLogData(logObject) {
             // Add a safety check for the passed object
             if (!logObject) {
                 console.error("formatLogData received undefined logObject");
                 return "[Error: Invalid log object received]";
             }
            const data = logObject.data; // Extract data from the passed log object

            // Keep sensitive formatting for background logs
            if (typeof data === 'string') {
                 try {
                     // Attempt to parse JSON only if it looks like JSON
                     if (data.trim().startsWith('{') || data.trim().startsWith('[')) {
                         const parsed = JSON.parse(data);
                         return JSON.stringify(parsed, null, 2); // Pretty print for background
                     }
                 } catch (e) { /* Ignore parsing error, return original string */ }
                 return data; // Return original string if not JSON or parsing failed
             } else if (typeof data === 'object' && data !== null) {
                 // Handle specific object structures for chat if needed, otherwise stringify for background
                 // Use the passed logObject here
                 if (logObject.role === 'StephAI' && logObject.type === 'llm_response' && data.content) {
                     return data.content; // Extract just the text content for chat
                 }
                 return JSON.stringify(data, null, 2); // Pretty print object for background
             }
             return String(data); // Fallback for other types
         }

         function updateSpinner() {
             if (backgroundTaskCount > 0) {
                 loadingSpinner.style.display = 'inline-block';
             } else {
                 loadingSpinner.style.display = 'none';
             }
         }

         function addLogEntry(log) {
             let targetContainer;
             let isBackgroundTask = true;
             // Pass the full log object (named 'log' in this scope) to formatLogData
             let formattedData = formatLogData(log);

             // Determine target container and if it's a background task
             if (log.role === 'StephAI' && log.type === 'llm_response') {
                 targetContainer = chatLogArea;
                 isBackgroundTask = false;
                 // Use the extracted content if available
                 formattedData = (typeof log.data === 'object' && log.data !== null && log.data.content) ? log.data.content : formattedData;
             } else if (log.role === 'scheduler') { // User/Scheduler messages also in chat
                 targetContainer = chatLogArea;
                 isBackgroundTask = false;
                 formattedData = (typeof log.data === 'object' && log.data !== null && log.data.content) ? log.data.content : formattedData;
             } else {
                 targetContainer = backgroundLogArea;
                 isBackgroundTask = true;
             }

             // Clear initial message
             if (targetContainer.textContent.includes("Waiting for StephAI...") || targetContainer.textContent.includes("Waiting for StephAI's first check...")) {
                 targetContainer.innerHTML = '';
             }

             // Create log entry elements
             const entryDiv = document.createElement('div');
             entryDiv.classList.add('log-entry');
             if (log.role) entryDiv.classList.add(`role-${log.role}`); // Add role class
             if (log.type) entryDiv.classList.add(`log-type-${log.type.split('_')[0]}`); // Add general type class (e.g., log-type-tool)
             if (log.type && log.type.includes('error')) entryDiv.classList.add('log-type-error'); // Specific error class

             // Add specific classes for chat styling
             if (targetContainer === chatLogArea) {
                 if (log.role === 'StephAI') entryDiv.classList.add('log-entry-stephai');
                 else if (log.role === 'scheduler') entryDiv.classList.add('log-entry-scheduler');
             }


             const timestampSpan = document.createElement('span');
             timestampSpan.classList.add('log-timestamp');
             timestampSpan.textContent = new Date(log.timestamp * 1000).toLocaleTimeString();

             const roleSpan = document.createElement('span');
             roleSpan.classList.add('log-role');
             roleSpan.textContent = `${log.role || 'system'}:`;

             const dataSpan = document.createElement('span');
             dataSpan.classList.add('log-data');
             dataSpan.textContent = formattedData; // Use pre-formatted data

             // Assemble entry
             entryDiv.appendChild(timestampSpan);
             // Only show role in background log for cleaner chat
             if (targetContainer === backgroundLogArea) {
                 entryDiv.appendChild(roleSpan);
             }
             entryDiv.appendChild(dataSpan);

             // Append to the correct container
             targetContainer.appendChild(entryDiv);

             // Scroll to bottom
             targetContainer.scrollTop = targetContainer.scrollHeight;

             // Update spinner logic
             if (isBackgroundTask) {
                 // Increment counter for starting tasks, decrement for ending tasks
                 if (log.type === 'tool_start' || log.type === 'llm_request') {
                     backgroundTaskCount++;
                 } else if (log.type === 'tool_result' || log.type === 'tool_error' || log.type === 'llm_response' || log.type === 'llm_error' || log.type === 'llm_tool_request') {
                     backgroundTaskCount = Math.max(0, backgroundTaskCount - 1); // Decrement, but not below 0
                 }
                 updateSpinner();
             }
         }


        // --- SSE Connection ---
        const eventSource = new EventSource("/stream_logs");

        eventSource.onopen = function() {
            console.log("SSE Connected");
        };

        eventSource.onmessage = function(event) {
             try {
                 const logEntry = JSON.parse(event.data);
                 addLogEntry(logEntry);
             } catch (e) {
                 console.error("Failed to parse SSE data:", event.data, e);
                 // Log parsing errors to the background log
                 addLogEntry({ type: 'stream_error', data: `Failed to parse log: ${event.data}`, timestamp: Date.now() / 1000, role: 'system' });
             }
         };

         eventSource.onerror = function(err) {
             console.error("EventSource failed:", err);
             // Log connection errors to the background log
             addLogEntry({ type: 'stream_error', data: 'Log stream connection error. Check console.', timestamp: Date.now() / 1000, role: 'system' });
             backgroundTaskCount = 0; // Reset counter on error
             updateSpinner();
         };

         // --- Background Log Collapse/Expand Logic ---
         const backgroundHeader = document.getElementById('background-header');
         const backgroundContainer = document.getElementById('background-work-container');
         const toggleIcon = backgroundHeader.querySelector('.toggle-icon');

         backgroundHeader.addEventListener('click', () => {
             backgroundContainer.classList.toggle('collapsed');
             if (backgroundContainer.classList.contains('collapsed')) {
                 toggleIcon.textContent = '+';
             } else {
                 toggleIcon.textContent = '-';
                 // Scroll to bottom when expanding
                 backgroundLogArea.scrollTop = backgroundLogArea.scrollHeight;
             }
         });

         // --- Database Table Loading & Refreshing Logic ---
         let tableLoaded = false; // Tracks initial load
         const tablePlaceholder = document.getElementById('table-placeholder');
         const tableContainer = document.getElementById('database-table-container'); // Get container reference

         async function refreshTableData() {
             console.log("Refreshing table data...");
             tablePlaceholder.textContent = 'Refreshing database content...'; // Update placeholder text
             tablePlaceholder.style.color = '#666'; // Reset color
             tableLoaded = false; // Reset flag to allow reload display logic

             // Clear existing table if it exists within the wrapper
             const existingWrapper = tablePlaceholder.querySelector('.db-table-wrapper');
             if (existingWrapper) {
                 tablePlaceholder.removeChild(existingWrapper);
             }

             await loadAndDisplayTable(); // Call the main loading function
         }

         async function loadAndDisplayTable() {
             // Removed the tableLoaded check here, refreshTableData handles preventing unnecessary calls if needed
             // tablePlaceholder is already defined outside

            try {
                const response = await fetch('/api/chefs');
                 if (!response.ok) {
                     throw new Error(`HTTP error! status: ${response.status}`);
                 }
                 const chefs = await response.json();

                 if (!Array.isArray(chefs) || chefs.length === 0) {
                     tablePlaceholder.textContent = 'No chef data found in the database.';
                     return;
                 }

                const columns = [
                    { key: 'id', header: 'ID' },
                    { key: 'name', header: 'Name' },
                    { key: 'status', header: 'Status' },
                    { key: 'restaurant_address', header: 'Address' },
                    { key: 'latitude', header: 'Lat' },
                    { key: 'longitude', header: 'Lon' },
                    { key: 'bio', header: 'Bio', className: 'col-bio' },
                    { key: 'last_updated', header: 'Last Updated' },
                 ];

                 const tableWrapper = document.createElement('div');
                 tableWrapper.classList.add('db-table-wrapper');
                 const table = document.createElement('table');
                 table.classList.add('db-table');
                 const thead = document.createElement('thead');
                 const tbody = document.createElement('tbody');
                 const headerRow = document.createElement('tr');

                columns.forEach(col => {
                    const th = document.createElement('th');
                    th.textContent = col.header;
                    if (col.className) {
                        th.classList.add(col.className);
                    }
                    headerRow.appendChild(th);
                });
                 thead.appendChild(headerRow);

                 chefs.forEach(chef => {
                     const row = document.createElement('tr');
                     columns.forEach(col => {
                         const td = document.createElement('td');
                         let value = chef[col.key];

                         // Handle potentially complex data like JSON
                         if (col.key === 'perplexity_data' && typeof value === 'object' && value !== null) {
                             value = '[JSON Data]';
                         }

                         // Use textContent for safety - this avoids the need for manual HTML escaping
                         td.textContent = (value === null || typeof value === 'undefined') ? '' : String(value);

                         if (col.className) {
                             td.classList.add(col.className);
                             // Add title attribute for potentially truncated columns
                             if (col.className === 'col-bio' || col.className === 'col-perplexity') {
                                 // Still set title attribute for hover text
                                 td.setAttribute('title', (value === null || typeof value === 'undefined') ? '' : String(value));
                             }
                         }
                         row.appendChild(td);
                     });
                     tbody.appendChild(row);
                 });

                 table.appendChild(thead);
                 table.appendChild(tbody);
                 tableWrapper.appendChild(table);

                 tablePlaceholder.innerHTML = ''; // Clear placeholder text/spinner
                 tablePlaceholder.appendChild(tableWrapper);
                 tableLoaded = true; // Mark as loaded after successful display

             } catch (error) {
                 console.error('Error loading or displaying database table:', error);
                 tablePlaceholder.textContent = `Error loading table data: ${error.message}. Check console for details.`;
                 tablePlaceholder.style.color = 'red';
             }
         }

         // --- View Toggle Logic ---
         const toggleButton = document.getElementById('view-toggle-button');
         const mapContainer = document.getElementById('map');
         // tableContainer is already defined above
         let currentView = 'map';

         toggleButton.addEventListener('click', () => {
             if (currentView === 'map') {
                 // Switch to Table View
                 mapContainer.style.display = 'none';
                 tableContainer.style.display = 'flex'; // Use flex now
                 toggleButton.textContent = 'Show Map';
                 currentView = 'table';
                 if (!tableLoaded) { // Only load initially if not already loaded
                    loadAndDisplayTable();
                 }
             } else {
                 // Switch to Map View
                 tableContainer.style.display = 'none';
                 mapContainer.style.display = 'block';
                 toggleButton.textContent = 'Show Table';
                 currentView = 'map';
                 setTimeout(() => {
                     map.invalidateSize();
                 }, 10);
             }
         });

         // --- Initial Load Calls ---
         document.addEventListener('DOMContentLoaded', () => {
              // Map/Log setup happens via inline script execution order
              // Table is loaded on demand by the toggle button click

              // --- SSE Connection for Database Updates ---
              const dbUpdateEventSource = new EventSource("/stream_db_updates");

              dbUpdateEventSource.onopen = function() {
                  console.log("DB Update SSE Connected");
              };

              dbUpdateEventSource.onmessage = function(event) {
                  try {
                      const updateSignal = JSON.parse(event.data);
                      console.log("Received DB update signal:", updateSignal);
                      if (updateSignal.event === "update" && currentView === 'table') {
                          // If the table is currently visible, refresh its data
                          refreshTableData();
                      }
                  } catch (e) {
                      console.error("Failed to parse DB Update SSE data:", event.data, e);
                      // Optionally log this to the background log area too
                      addLogEntry({ type: 'db_stream_error', data: `Failed to parse DB update signal: ${event.data}`, timestamp: Date.now() / 1000, role: 'system' });
                  }
              };

              dbUpdateEventSource.onerror = function(err) {
                  console.error("DB Update EventSource failed:", err);
                  addLogEntry({ type: 'db_stream_error', data: 'DB Update stream connection error. Check console.', timestamp: Date.now() / 1000, role: 'system' });
              };
          });


      </script>

 </body>
 </html>
