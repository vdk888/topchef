<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Top Chef France â€“ Chef Explorer</title>
    <link rel="icon" type="image/png" href="/static/favicon.png">
    <meta name="description" content="Discover France's top chefs by location, season, and status. Explore culinary excellence with Top Chef France.">
    <meta name="theme-color" content="#111111"> <!-- Updated theme color -->
    <link href="https://fonts.googleapis.com/css?family=Montserrat:700&display=swap" rel="stylesheet"> <!-- Only Montserrat Bold -->
    <!-- Leaflet CSS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
          integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
          crossorigin=""/>
    <!-- Leaflet JavaScript -->
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
            integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
            crossorigin=""></script>
    
    <!-- Leaflet Locate Control for current location -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/leaflet.locatecontrol@0.79.0/dist/L.Control.Locate.min.css" />
    <script src="https://cdn.jsdelivr.net/npm/leaflet.locatecontrol@0.79.0/dist/L.Control.Locate.min.js"></script>

    <style>
        :root {
            /* M6 Top Chef Inspired Palette */
            --m6-bg: #111111; /* Dark background */
            --m6-bg-secondary: #222222; /* Slightly lighter bg for elements */
            --m6-border: #444444; /* Borders */
            --m6-text-primary: #e0e0e0; /* Primary light text */
            --m6-text-secondary: #a0a0a0; /* Secondary light text */
            --m6-text-dark: #111111; /* Dark text for light backgrounds */
            --tcf-yellow: #ffc72c; /* Accent yellow */
            --m6-white: #ffffff;
            --m6-shadow: none; /* Flatten design */
            --m6-shadow-light: none; /* Flatten design */
        }
        html, body {
            height: 100%;
            margin: 0;
            padding: 0;
            font-family: Arial, Helvetica, sans-serif; /* Standard sans-serif */
            background-color: var(--m6-bg);
            color: var(--m6-text-primary);
            display: flex;
            flex-direction: column;
            font-size: 14px; /* Base font size */
        }

        .header {
            padding: 15px 30px; /* Reduced padding */
            background-color: var(--m6-bg-secondary); /* Use secondary bg */
            color: var(--m6-text-primary);
            box-shadow: var(--m6-shadow); /* Removed shadow */
            border-bottom: 3px solid var(--m6-border); /* Thinner, darker border */
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-shrink: 0; /* Prevent header from shrinking */
        }
        .header .title-group h1 {
            font-family: 'Montserrat', sans-serif; /* Keep Montserrat for main title */
            font-weight: 700;
            font-size: 1.8em; /* Reduced size */
            margin: 0;
            letter-spacing: 1px;
            color: var(--tcf-yellow); /* Keep yellow accent */
            text-shadow: none; /* Remove text shadow */
        }
        .header .title-group p {
            margin: 2px 0 0 1px; /* Adjusted margin */
            font-size: 1em; /* Reduced size */
            color: var(--m6-text-secondary); /* Use secondary text color */
            font-family: Arial, Helvetica, sans-serif; /* Standard sans-serif */
            font-style: normal; /* Remove italic */
            letter-spacing: 0.5px;
        }
        #view-toggle-button {
            padding: 8px 18px; /* Adjusted padding */
            font-size: 0.9em; /* Adjusted size */
            font-family: Arial, Helvetica, sans-serif; /* Standard font */
            cursor: pointer;
            background-color: var(--m6-bg-secondary); /* Match header bg */
            color: var(--m6-text-primary); /* Light text */
            border: 1px solid var(--m6-border); /* Use theme border */
            border-radius: 3px; /* Sharper corners */
            box-shadow: var(--m6-shadow-light); /* Removed shadow */
            transition: background-color 0.2s, color 0.2s, border-color 0.2s;
        }
        #view-toggle-button:hover {
            background-color: var(--m6-border); /* Darker bg on hover */
            border-color: var(--tcf-yellow); /* Yellow border on hover */
            color: var(--tcf-yellow); /* Yellow text on hover */
            transform: none; /* Remove lift */
        }

        /* Style for the Season Filter Select */
        #season-filter {
            padding: 7px 25px 7px 10px; /* Adjusted padding */
            font-size: 0.9em; /* Adjusted size */
            font-family: Arial, Helvetica, sans-serif; /* Standard font */
            cursor: pointer;
            background-color: var(--m6-bg-secondary); /* Match header bg */
            color: var(--m6-text-primary); /* Light text */
            border: 1px solid var(--m6-border); /* Use theme border */
            border-radius: 3px; /* Sharper corners */
            margin-right: 15px;
            box-shadow: var(--m6-shadow-light); /* Removed shadow */
            appearance: none;
            -webkit-appearance: none;
            -moz-appearance: none;
            /* Simple arrow using SVG */
            background-image: url('data:image/svg+xml;charset=US-ASCII,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20viewBox%3D%220%200%2010%205%22%3E%3Cpath%20fill%3D%22%23a0a0a0%22%20d%3D%22M0%200l5%205%205-5z%22%2F%3E%3C%2Fsvg%3E');
            background-repeat: no-repeat;
            background-position: right 8px top 50%;
            background-size: 10px auto;
            transition: border-color 0.2s;
        }
        #season-filter:hover {
            border-color: var(--tcf-yellow); /* Yellow border on hover */
        }
        #season-filter:focus {
            outline: none;
            border-color: var(--tcf-yellow);
            box-shadow: 0 0 0 2px rgba(255, 199, 44, 0.4); /* Subtle yellow focus ring */
        }
        /* Label for the filter */
        label[for="season-filter"] {
            color: var(--m6-text-secondary); /* Use secondary text color */
            margin-right: 8px;
            font-family: Arial, Helvetica, sans-serif; /* Standard font */
            font-size: 0.9em; /* Adjusted size */
        }


        .main-content {
            display: flex;
            flex-grow: 1;
            overflow: hidden; /* Prevent content overflow */
            padding: 15px; /* Increased padding */
            gap: 15px; /* Increased gap */
            min-height: 0; /* Allow flex items to shrink properly */
        }

        .primary-view-container {
            flex-basis: 65%; /* Use flex-basis */
            min-width: 0; /* Allow shrinking */
            position: relative;
            border-radius: 3px; /* Sharper corners */
            box-shadow: var(--m6-shadow); /* Removed shadow */
            background-color: var(--m6-white); /* Keep white for map/table bg */
            overflow: hidden;
            border: 1px solid var(--m6-border); /* Add border */
            display: flex; /* Ensure map/table fills container */
            flex-direction: column;
        }

        #map {
            height: 100%;
            width: 100%;
            flex-grow: 1; /* Allow map to fill space */
        }

        .sidebar {
            flex-basis: 35%; /* Use flex-basis */
            min-width: 0; /* Allow shrinking */
            display: flex;
            flex-direction: column;
            background: var(--m6-bg-secondary); /* Use secondary bg */
            border-radius: 3px; /* Sharper corners */
            border: 1px solid var(--m6-border); /* Use theme border */
            box-shadow: var(--m6-shadow); /* Removed shadow */
            overflow: hidden; /* Prevents content spill */
        }

        /* Simplified Sidebar Headers */
        .sidebar h2, .background-header span, #interactive-chat-header span {
            font-family: Arial, Helvetica, sans-serif; /* Standard font */
            font-size: 1em; /* Adjusted size */
            font-weight: bold;
            color: var(--m6-text-primary); /* Light text */
            letter-spacing: 0.5px;
            margin: 0; /* Reset margin */
        }
        .header-row, #background-header, #interactive-chat-header {
            background: none; /* Remove gradient/color */
            padding: 10px 15px; /* Adjusted padding */
            box-shadow: none; /* Remove shadow */
            border-radius: 0; /* Remove rounding */
            border-bottom: 1px solid var(--m6-border); /* Add bottom border */
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-shrink: 0; /* Prevent headers from shrinking */
        }
        #main-chat-container {
            flex-basis: 60%;
            border-bottom: none; /* Remove yellow border */
            background: transparent;
            display: flex;
            flex-direction: column;
            overflow: hidden; /* Contain children */
            min-height: 0; /* Allow shrinking */
        }
        #background-work-container {
            flex-basis: 40%;
            background: transparent;
            display: flex;
            flex-direction: column;
            border-top: 1px solid var(--m6-border); /* Add separator */
            overflow: hidden; /* Contain children */
            min-height: 0; /* Allow shrinking */
        }
        #interactive-chat-container {
            background: transparent;
            border-top: 1px solid var(--m6-border); /* Use standard border */
            flex-basis: 35%; /* Keep ratio */
            min-height: 180px; /* Keep min height for usability */
            display: flex;
            flex-direction: column;
            overflow: hidden; /* Contain children */
        }
        #chat-log-area, #background-log-area, #interactive-chat-log-area {
            flex-grow: 1;
            overflow-y: auto;
            padding: 10px;
            background: transparent; /* Remove subtle background */
            min-height: 0; /* Allow shrinking */
        }
        #chat-log-area { color: var(--m6-text-primary); }
        #background-log-area { color: var(--m6-text-secondary); } /* Keep secondary for background */
        #interactive-chat-log-area { color: var(--m6-text-primary); }

        /* M6 Theme Chat Bubbles & Log Entries */
        #chat-log-area .log-entry.log-entry-stephai-botenberg,
        #interactive-chat-log-area .ai-msg {
            background: var(--m6-bg-secondary); /* Use secondary bg */
            color: var(--m6-text-primary); /* Light text */
            border: 1px solid var(--m6-border);
            box-shadow: none;
            border-radius: 6px; /* Slightly rounded */
            padding: 10px 15px;
            margin: 8px 40px 8px 8px; /* Adjust margins */
            text-align: left;
        }
        #chat-log-area .log-entry.log-entry-scheduler,
        #interactive-chat-log-area .user-msg {
            background: #333; /* Slightly different dark bg for user/scheduler */
            color: var(--m6-text-primary); /* Light text */
            border: 1px solid var(--m6-border);
            box-shadow: none;
            border-radius: 6px;
            padding: 10px 15px;
            margin: 8px 8px 8px 40px; /* Adjust margins */
            text-align: right;
        }

        /* General Log Entry Styling */
        .log-entry {
            margin-bottom: 8px; /* Reduced margin */
            padding-bottom: 8px;
            border-bottom: 1px solid var(--m6-border); /* Use theme border */
        }
        .log-entry:last-child { border-bottom: none; }

        /* Background Log Specific Styling */
        #background-log-area .log-entry {
            background: none; /* Remove specific background */
            color: var(--m6-text-secondary); /* Use secondary text */
            border-radius: 0;
            padding: 4px 0; /* Minimal padding */
            margin-bottom: 4px;
            border: none; /* Remove border */
            font-size: 0.85em; /* Smaller font */
            border-bottom: none; /* Override general log entry border */
        }

        .log-timestamp {
            color: var(--m6-text-secondary); /* Use secondary text */
            margin-right: 8px;
            font-size: 0.85em; /* Match background log */
            opacity: 0.7;
            font-family: Arial, Helvetica, sans-serif; /* Standard font */
        }
        /* Timestamp inside chat bubbles */
        #chat-log-area .log-entry .log-timestamp,
        #interactive-chat-log-area .log-entry .log-timestamp {
             color: var(--m6-text-secondary);
             opacity: 0.7;
        }
        .log-role {
            font-weight: bold;
            margin-right: 5px;
            font-family: Arial, Helvetica, sans-serif; /* Standard font */
            color: var(--m6-text-secondary); /* Use secondary text color */
        }
        /* Highlight StephAI role slightly in background log */
         #background-log-area .role-StephAI-Botenberg .log-role {
            color: var(--m6-text-primary);
         }


        #database-table-container {
            height: 100%;
            width: 100%;
            padding: 20px; /* Adjusted padding */
            overflow: auto;
            display: none;
            box-sizing: border-box;
            flex-direction: column;
            border-radius: 0; /* Remove rounding */
            background: var(--m6-white);
            box-shadow: none;
            color: var(--m6-text-dark);
        }

        #database-table-container h2 {
            margin: 0 0 15px 0;
            padding-bottom: 10px;
            border-bottom: 2px solid var(--tcf-yellow); /* Keep yellow accent border */
            font-size: 1.3em; /* Adjusted size */
            color: var(--m6-text-dark); /* Dark text */
            font-family: Arial, Helvetica, sans-serif; /* Standard font */
            font-weight: bold;
        }

        .db-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.9em; /* Adjusted size */
            font-family: Arial, Helvetica, sans-serif; /* Standard font */
        }

        .db-table th, .db-table td {
            border: 1px solid #ddd; /* Lighter border for table */
            padding: 10px 12px; /* Increased padding slightly */
            text-align: left;
            vertical-align: top; /* Align content to top */
        }

        .db-table th {
            white-space: nowrap; /* Keep headers from wrapping */
            position: sticky; /* Make header sticky */
            top: 0; /* Stick to the top of the container */
            z-index: 10; /* Ensure header is above content */
            background-color: var(--m6-bg-secondary); /* Ensure background */
            color: var(--m6-text-primary);
            font-weight: bold;
        }

        .db-table td {
            white-space: normal; /* Allow content wrapping by default */
            word-break: break-word; /* Help break long words if needed */
        }

        .db-table tr:nth-child(even) {
            background-color: #f9f9f9; /* Very light grey for zebra */
        }

        .db-table tr:hover {
            background-color: #f0f0f0; /* Slightly darker hover */
        }

        .db-table .col-bio {
            min-width: 150px; /* Give bio some minimum space */
        }

        .db-table td.col-id,
        .db-table td.col-season_number,
        .db-table td.col-current_restaurant {
            white-space: nowrap; /* Prevent wrapping for short IDs/numbers */
            text-align: center;
        }

        .db-table td.col-image_url {
             width: 70px; /* Fixed width for image column */
             text-align: center;
        }
        .db-table td.col-image_url img {
             max-width: 50px; /* Consistent image size */
             max-height: 50px;
             display: block;
             margin: auto; /* Center image */
        }

        .db-table td.col-perplexity_data pre {
            max-width: 300px; /* Limit width */
            overflow-x: auto; /* Allow horizontal scroll if needed */
            white-space: pre-wrap; /* Wrap but preserve formatting */
            word-break: break-all; /* Break long strings */
            background: #f0f0f0;
            padding: 5px;
            border-radius: 3px;
            font-size: 0.85em;
            color: #333; /* Dark text on light background */
            margin: 0; /* Remove default margin */
        }

        #interactive-chat-input-row {
            display: flex;
            padding: 10px;
            background: var(--m6-bg-secondary); /* Match sidebar bg */
            border-top: 1px solid var(--m6-border); /* Standard border */
            flex-shrink: 0; /* Prevent input row from shrinking */
        }
        
        /* Agent History Link Styling */
        .nav-links {
            display: flex;
            align-items: center;
            margin-right: 20px;
        }
        
        .agent-history-link {
            color: var(--tcf-yellow);
            text-decoration: none;
            font-size: 0.9em;
            padding: 5px 10px;
            border: 1px solid var(--m6-border);
            border-radius: 3px;
            background: var(--m6-bg-secondary);
            transition: all 0.2s ease;
        }
        
        .agent-history-link:hover {
            background: var(--m6-border);
            color: var(--m6-white);
            border-color: var(--tcf-yellow);
        }

        #interactive-chat-input {
            flex: 1;
            padding: 8px 10px;
            font-size: 0.9em;
            border: 1px solid var(--m6-border);
            border-radius: 3px; /* Sharper corners */
            margin-right: 10px;
            background-color: var(--m6-bg); /* Dark input bg */
            color: var(--m6-text-primary); /* Light text */
        }
        #interactive-chat-input:focus {
             outline: none;
             border-color: var(--tcf-yellow);
             box-shadow: 0 0 0 2px rgba(255, 199, 44, 0.4); /* Subtle yellow focus */
        }

        #interactive-chat-send {
            padding: 8px 15px;
            font-size: 0.9em;
            font-family: Arial, Helvetica, sans-serif; /* Standard font */
            background: var(--m6-border); /* Use border color for button */
            color: var(--m6-text-primary); /* Light text */
            border: none;
            border-radius: 3px; /* Sharper corners */
            cursor: pointer;
            transition: background-color 0.2s, color 0.2s;
        }
        #interactive-chat-send:hover {
            background: var(--tcf-yellow); /* Yellow bg on hover */
            color: var(--m6-text-dark); /* Dark text on hover */
            transform: none; /* Remove lift */
        }

        #interactive-chat-send:disabled {
            background: #333; /* Darker disabled bg */
            color: var(--m6-text-secondary); /* Dim text */
            cursor: not-allowed;
            transform: none;
        }


        /* Cleaner Enlarge/Collapse Icons */
        .enlarge-btn, .toggle-icon {
            font-family: sans-serif; /* Use generic for icons */
            font-weight: bold;
            font-size: 1.2em;
            line-height: 1;
        }
        .enlarge-btn {
            background: none;
            border: none;
            cursor: pointer;
            margin-left: 10px;
            color: var(--m6-text-secondary); /* Secondary text color */
            transition: color 0.2s;
            padding: 0;
        }
        .enlarge-btn:hover {
            color: var(--tcf-yellow); /* Yellow on hover */
        }
        .enlarge-btn:focus { outline: none; }

        /* Use +/- for toggle */
        .toggle-icon {
             color: var(--m6-text-secondary);
             margin-left: 5px;
             cursor: pointer; /* Make icon clickable */
        }
        .toggle-icon:hover { color: var(--tcf-yellow); }

        /* Adjust spinner */
        #background-header .spinner {
            /* Add spinner styles if needed, e.g., border color */
            border-top-color: var(--tcf-yellow);
            width: 14px; height: 14px; /* Smaller */
            margin-right: 8px;
        }


        .sidebar.enlarged-agent #main-chat-container,
        .sidebar.enlarged-bg #background-work-container,
        .sidebar.enlarged-interactive #interactive-chat-container {
            flex-basis: 100% !important;
            height: 100%;
            display: flex;
        }

        .sidebar.enlarged-agent #background-work-container,
        .sidebar.enlarged-agent #interactive-chat-container,
        .sidebar.enlarged-bg #main-chat-container,
        .sidebar.enlarged-bg #interactive-chat-container,
        .sidebar.enlarged-interactive #main-chat-container,
        .sidebar.enlarged-interactive #background-work-container {
            display: none !important;
        }

        /* Styles for Map Popups */
        .leaflet-popup-content-wrapper {
            background: var(--m6-bg-secondary); /* Dark popup bg */
            color: var(--m6-text-primary); /* Light text */
            border-radius: 4px; /* Sharper corners */
            box-shadow: none; /* Remove shadow */
            border: 1px solid var(--m6-border);
        }
        .leaflet-popup-content {
            margin: 12px 18px; /* Adjusted padding */
            font-family: Arial, Helvetica, sans-serif; /* Standard font */
            line-height: 1.5;
            font-size: 0.9em;
        }
        .leaflet-popup-content h3 {
            font-family: 'Montserrat', sans-serif; /* Keep Montserrat */
            color: var(--tcf-yellow); /* Yellow title */
            margin: 0 0 8px 0;
            padding-bottom: 4px;
            border-bottom: 1px solid var(--m6-border); /* Theme border */
            font-size: 1.1em;
        }
        .leaflet-popup-content p {
            margin: 4px 0;
        }
        .leaflet-popup-content strong {
            color: var(--m6-text-primary); /* Primary light text for strong */
            font-weight: bold;
        }
        .popup-image {
            max-width: 100%;
            height: auto;
            margin-top: 8px;
            border-radius: 3px;
            border: 1px solid var(--m6-border);
        }
        .missing-data {
            color: var(--m6-text-secondary); /* Secondary text for missing */
            font-style: italic;
            font-size: 0.9em;
        }
        .leaflet-popup-tip {
            background: var(--m6-bg-secondary); /* Match popup bg */
        }

        /* Map Popup Styling */
        .leaflet-popup-content-wrapper {
            border-radius: 5px; /* Slightly rounder corners */
        }
        .leaflet-popup-content {
            margin: 10px 15px; /* Adjust popup padding */
            font-family: Arial, sans-serif;
            font-size: 0.95em;
            line-height: 1.5;
        }
        .popup-container h3 {
            margin: 0 0 8px 0;
            font-size: 1.2em;
            border-bottom: 1px solid #eee;
            padding-bottom: 5px;
        }
        .popup-image {
            max-width: 100%; /* Allow image to fill width if needed */
            max-height: 120px; /* Limit height */
            display: block; /* Center image */
            margin: 5px auto 10px auto; /* Spacing around image */
            border-radius: 3px;
            object-fit: cover; /* Cover area nicely */
        }
        .popup-field {
            margin: 0 0 5px 0; /* Spacing between fields */
        }
        .popup-field strong {
             color: #333;
        }
        .popup-map-link a {
            color: var(--tcf-yellow);
            text-decoration: none;
            font-weight: bold;
        }
        .popup-map-link a:hover {
            text-decoration: underline;
        }

        /* --- Responsive Design --- */
        /* Fullscreen control styling */
        .leaflet-control-fullscreen a {
            background-color: #fff;
            background-position: center;
            background-size: 16px 16px;
            border-radius: 4px;
            box-shadow: 0 1px 5px rgba(0,0,0,0.4);
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        /* Ensure fullscreen works properly on mobile */
        .leaflet-touch .leaflet-control-fullscreen a {
            width: 44px;
            height: 44px;
        }
        
        /* Ensure map takes full screen when in fullscreen mode */
        .fullscreen-map {
            position: fixed !important;
            width: 100% !important;
            height: 100% !important;
            top: 0 !important;
            left: 0 !important;
            z-index: 99999 !important;
            background-color: white;
        }
        
        /* Style for locate control */
        .leaflet-control-locate a {
            font-size: 1.4em;
        }
        
        .leaflet-touch .leaflet-control-locate a {
            width: 44px;
            height: 44px;
        }
        
        @media (max-width: 768px) {
            html, body {
                font-size: 13px; /* Slightly smaller base font for mobile */
            }
            
            /* Make map controls more visible and touchable on mobile */
            .leaflet-control-fullscreen a,
            .leaflet-control-locate a {
                width: 44px !important;
                height: 44px !important;
                font-size: 1.5em !important;
                display: flex !important;
                align-items: center !important;
                justify-content: center !important;
            }
            
            /* Ensure SVG icons are properly sized */
            .leaflet-control-fullscreen a svg {
                width: 24px !important;
                height: 24px !important;
            }
            
            /* Add some space between controls */
            .leaflet-control-container .leaflet-top .leaflet-control {
                margin-top: 10px !important;
            }
            .header {
                padding: 10px 15px; /* Reduced header padding */
                flex-direction: column; /* Stack title and controls */
                align-items: flex-start; /* Align items left */
                gap: 10px; /* Add gap between title and controls */
            }
            .header .title-group h1 {
                font-size: 1.5em; /* Smaller title */
            }
             .header .title-group p {
                font-size: 0.9em; /* Smaller subtitle */
            }
            .header > div:last-child { /* Target the controls container */
                 display: flex;
                 width: 100%; /* Make controls take full width */
                 justify-content: space-between; /* Space out controls */
                 align-items: center;
            }
             #season-filter {
                 padding: 6px 20px 6px 8px; /* Adjust padding */
                 font-size: 0.85em;
                 margin-right: 10px; /* Adjust margin */
                 flex-grow: 1; /* Allow filter to take available space */
            }
             #view-toggle-button {
                 padding: 7px 15px; /* Adjust padding */
                 font-size: 0.85em;
            }

            .main-content {
                flex-direction: column; /* Stack main sections */
                padding: 10px; /* Adjust padding */
                gap: 10px; /* Adjust gap */
                overflow-y: auto; /* Allow vertical scroll for the whole content area if needed */
                height: calc(100% - 70px); /* Adjust height considering header */
            }
            .primary-view-container, .sidebar {
                width: 100%; /* Full width */
                flex-basis: auto; /* Reset flex-basis */
                height: 50%; /* Approximate height split, adjust as needed */
                min-height: 300px; /* Ensure minimum usable height */
            }
            .sidebar {
                 height: auto; /* Allow sidebar to grow based on content */
                 min-height: 400px; /* Ensure sidebar is usable */
            }

             /* Adjust sidebar section distribution */
             #main-chat-container, #background-work-container, #interactive-chat-container {
                 flex-basis: auto; /* Let content determine height more */
             }
             #interactive-chat-container {
                 min-height: 150px; /* Slightly smaller min-height */
             }

             /* Ensure table scrolls horizontally if needed */
             .db-table-wrapper {
                 overflow-x: auto;
             }
             #database-table-container {
                 padding: 10px; /* Adjust padding for card view */
             }

             /* Card View for Table on Mobile */
             .db-table thead {
                 display: none; /* Hide table header */
             }
             .db-table tr {
                 display: block;
                 margin-bottom: 15px;
                 border: 1px solid var(--m6-border);
                 border-radius: 3px;
                 box-shadow: 0 2px 4px rgba(0,0,0,0.1);
                 background-color: var(--m6-white);
                 padding: 10px;
             }
            .db-table td {
                display: block;
                text-align: right; /* Align value to the right */
                padding: 6px 0; /* Vertical padding only */
                border: none; /* Remove cell borders */
                border-bottom: 1px dashed #eee; /* Subtle separator */
                white-space: normal; /* Allow all cells to wrap */
                position: relative;
                padding-left: 50%; /* Create space for the label */
                min-height: 1.5em; /* Ensure space even if value is short */
            }
            .db-table td:last-child {
                border-bottom: none;
            }
            .db-table td::before {
                content: attr(data-label); /* Use data-label for the label */
                position: absolute;
                left: 5px; /* Position label on the left */
                width: calc(50% - 10px); /* Calculate label width */
                padding-right: 10px;
                font-weight: bold;
                text-align: left;
                white-space: normal;
                color: var(--m6-text-dark); /* Use dark text for labels */
            }
            /* Adjust specific cells like images or preformatted text */
            .db-table td img {
                 max-width: 40px !important; /* Smaller images in card view */
                 max-height: 40px !important;
                 float: right; /* Float image right */
            }
            .db-table td pre {
                 text-align: left; /* Align pre content left */
                 padding-left: 0; /* Remove extra padding */
                 white-space: pre-wrap;
                 word-break: break-all;
                 max-height: 100px; /* Limit height */
                 overflow-y: auto; /* Add scroll if needed */
            }

             /* .db-table .col-bio { } -- Remove this empty rule */

             .db-table td img {
                 max-width: 40px !important; /* Smaller images in card view */
                 max-height: 40px !important;
                 float: right; /* Float image right */
            }
            .db-table td pre {
                 text-align: left; /* Align pre content left */
                 padding-left: 0; /* Remove extra padding */
                 white-space: pre-wrap;
                 word-break: break-all;
                 max-height: 100px; /* Limit height */
                 overflow-y: auto; /* Add scroll if needed */
            }

        }

        /* --- Animations & Transitions --- */
        /* Smooth transition for sidebar enlarge */
        .sidebar > div { /* Target direct children of sidebar */
             transition: flex-basis 0.4s ease-in-out, opacity 0.4s ease-in-out;
        }
        .sidebar.enlarged-agent #background-work-container,
        .sidebar.enlarged-agent #interactive-chat-container,
        .sidebar.enlarged-bg #main-chat-container,
        .sidebar.enlarged-bg #interactive-chat-container,
        .sidebar.enlarged-interactive #main-chat-container,
        .sidebar.enlarged-interactive #background-work-container {
             flex-basis: 0 !important;
             opacity: 0;
             overflow: hidden; /* Hide content during transition */
        }

        /* Fade-in for table */
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        #database-table-container {
            animation: fadeIn 0.5s ease-in-out;
        }

        /* Background log collapse/expand transition */
        #background-header .spinner {
            /* Add spinner styles if needed, e.g., border color */
            border-top-color: var(--tcf-yellow);
            width: 14px; height: 14px; /* Smaller */
            margin-right: 8px;
        }
        #background-work-container .background-header {
             cursor: pointer; /* Indicate clickable header */
        }
        #background-log-area {
             transition: max-height 0.4s ease-in-out, padding 0.4s ease-in-out, opacity 0.3s ease-in-out;
             max-height: 300px; /* Adjust as needed for default visible height */
             overflow: hidden;
             opacity: 1;
        }
         #background-work-container.collapsed #background-log-area {
             max-height: 0;
             padding-top: 0;
             padding-bottom: 0;
             opacity: 0;
             border-top: none; /* Hide border when collapsed */
         }
         #background-work-container.collapsed {
             border-top: 1px solid var(--m6-border); /* Ensure top border remains */
         }
         #background-work-container:not(.collapsed) #background-log-area {
              border-top: 1px solid var(--m6-border); /* Show border when expanded */
         }

        /* Welcome Message Style */
        .welcome-message {
            padding: 15px;
            margin: 10px 8px; /* Match bubble margins */
            background-color: rgba(255, 199, 44, 0.1); /* Subtle yellow background */
            border: 1px solid var(--tcf-yellow);
            border-radius: 6px;
            color: var(--m6-text-primary);
            font-style: italic;
            text-align: center;
            font-size: 0.95em;
        }
        .welcome-message strong {
             color: var(--tcf-yellow);
             font-weight: bold;
        }

        /* Map Fullscreen Button */
        #fullscreen-map-button {
            position: absolute;
            top: 10px;
            right: 10px;
            z-index: 1000; /* Ensure it's above map tiles */
            background-color: rgba(255, 255, 255, 0.8);
            color: #333;
            border: 1px solid #ccc;
            border-radius: 4px;
            padding: 5px 8px;
            cursor: pointer;
            font-size: 1.2em;
            line-height: 1;
            box-shadow: 0 1px 3px rgba(0,0,0,0.2);
        }
        #fullscreen-map-button:hover {
            background-color: white;
        }
    </style>
</head>
<body>

    <div class="header">
        <div class="title-group">
            <h1>Top Chef France</h1>
            <p>Chef Explorer</p>
        </div>
        <div class="nav-links">
            <a href="/agent/history" class="agent-history-link">Agent History</a>
        </div>
        <div>
            <label for="season-filter">Season:</label>
            <select id="season-filter">
                <option value="">All Seasons</option>
            </select>
            <button id="view-toggle-button">Show Table</button>
        </div>
    </div>

    <div class="main-content">
        <!-- Primary View Container (Map or Table) -->
        <div class="primary-view-container">
            <div id="map"></div>
            <button id="fullscreen-map-button" title="Toggle Fullscreen">&#x2922;</button> <!-- Fullscreen symbol -->
            <!-- Database Table Section (initially hidden) -->
            <div id="database-table-container">
                <h2>Chef Database</h2> <!-- Simplified Title -->
                <div id="table-placeholder">Loading database content...</div>
                <!-- Table structure remains the same, styling handled by CSS -->
                <div class="db-table-wrapper"> <!-- Added wrapper for potential future scrollbars -->
                     <table class="db-table">
                         <thead id="database-table-head">
                         </thead>
                         <tbody id="database-table-body">
                         </tbody>
                     </table>
                 </div>
            </div>
        </div>

        <!-- Sidebar Log -->
        <div class="sidebar">
            <!-- Main Chat Area -->
            <div id="main-chat-container">
                <div class="header-row"> <!-- Use class for consistent styling -->
                    <h2>StephAI travaille</h2>
                    <button class="enlarge-btn" id="enlarge-agent" title="Enlarge">&#x2922;</button> <!-- Expand icon -->
                </div>
                <div id="chat-log-area">
                    <div class="welcome-message">
                        <strong>Bienvenue sur le Chef Explorer !</strong><br>
                        DÃ©couvrez les candidats de Top Chef, leurs restaurants, et posez vos questions Ã  notre agent interactif ci-dessous. StephAI Botenberg ajoutera bientÃ´t ses propres commentaires ici !
                    </div>
                    <!-- Dynamic logs will be added here by JS -->
                </div>
            </div>
            <!-- Background Activity Area -->
            <div id="background-work-container" class="collapsed">
                <div class="background-header" id="background-header"> <!-- Use ID for JS, class for styling -->
                    <span>Background Activity</span> <!-- Simplified -->
                    <div>
                        <div class="spinner" id="loading-spinner" style="display: none;"></div> <!-- Hide initially -->
                        <span class="toggle-icon">+</span>
                    </div>
                    <button class="enlarge-btn" id="enlarge-bg" title="Enlarge">&#x2922;</button> <!-- Expand icon -->
                </div>
                <div id="background-log-area"></div>
            </div>
            <!-- Interactive Chat Area -->
            <div id="interactive-chat-container">
                <div id="interactive-chat-header"> <!-- Use ID for JS, class for styling -->
                    <span>Discutez avec StephAI</span> <!-- Simplified -->
                    <button class="enlarge-btn" id="enlarge-interactive" title="Enlarge">&#x2922;</button> <!-- Expand icon -->
                </div>
                <div id="interactive-chat-log-area"></div>
                <div id="interactive-chat-input-row">
                    <input type="text" id="interactive-chat-input" placeholder="Ask about chefs, seasons, locations..." autocomplete="off" />
                    <button id="interactive-chat-send">Send</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Embed JSON data safely -->
    <script id="chefs-data" type="application/json">
        {{ all_chef_data|safe }} {# Use the correct variable 'all_chef_data' passed from Flask #}
    </script>
    <!-- Embed column names JSON safely -->
    <script id="column-names-data" type="application/json">
        {{ column_names|tojson|safe }}
    </script>

    <script>
        // --- Global Variables & Constants ---
        window.BACKGROUND_LOG_KEY = 'topchef_background_logs'; // Restore definition
        window.INTERACTIVE_LOG_KEY = 'topchef_interactive_logs'; // Restore definition
        window.MAIN_LOG_KEY = 'topchef_main_logs'; // Key for StephAI's main messages
        // const globalColumnNames = {{ column_names|tojson }}; // Removed direct assignment
        let globalColumnNames = []; // Initialize as empty array
        try {
            const colNamesDataElement = document.getElementById('column-names-data');
            if (colNamesDataElement) {
                const rawColNamesJson = colNamesDataElement.textContent || colNamesDataElement.innerText;
                globalColumnNames = JSON.parse(rawColNamesJson);
            } else {
                 console.error("Could not find column-names-data script tag.");
            }
        } catch (e) {
            console.error("Error processing column names JSON data:", e);
        }
        let backgroundLogArea = document.getElementById('background-log-area');
        let interactiveLogArea = document.getElementById('interactive-chat-log-area');
        let chatLogArea = document.getElementById('chat-log-area'); // Area for StephAI's main commentary
        let logCounter = 0;
        const maxLogEntries = 200; // Limit stored log entries

        // --- Map Initialization ---
        // Center roughly on France
        const map = L.map('map').setView([46.603354, 1.888334], 6);
        
        // Add locate control for current location
        const locateControl = L.control.locate({
            position: 'topleft',
            strings: {
                title: "Show my location"
            },
            locateOptions: {
                enableHighAccuracy: true,
                maxZoom: 15
            }
        }).addTo(map);
        
        // Add custom fullscreen control
        const fullscreenControl = L.Control.extend({
            options: {
                position: 'topleft'
            },
            
            onAdd: function (map) {
                const container = L.DomUtil.create('div', 'leaflet-bar leaflet-control leaflet-control-custom');
                const button = L.DomUtil.create('a', 'leaflet-control-fullscreen', container);
                button.href = '#';
                button.title = 'View Fullscreen';
                button.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path d="M1.5 1a.5.5 0 0 0-.5.5v4a.5.5 0 0 1-1 0v-4A1.5 1.5 0 0 1 1.5 0h4a.5.5 0 0 1 0 1h-4zM10 .5a.5.5 0 0 1 .5-.5h4A1.5 1.5 0 0 1 16 1.5v4a.5.5 0 0 1-1 0v-4a.5.5 0 0 0-.5-.5h-4a.5.5 0 0 1-.5-.5zM.5 10a.5.5 0 0 1 .5.5v4a.5.5 0 0 0 .5.5h4a.5.5 0 0 1 0 1h-4A1.5 1.5 0 0 1 0 14.5v-4a.5.5 0 0 1 .5-.5zm15 0a.5.5 0 0 1 .5.5v4a1.5 1.5 0 0 1-1.5 1.5h-4a.5.5 0 0 1 0-1h4a.5.5 0 0 0 .5-.5v-4a.5.5 0 0 1 .5-.5z"/></svg>';
                button.style.width = '30px';
                button.style.height = '30px';
                button.style.backgroundColor = 'white';
                button.style.display = 'flex';
                button.style.alignItems = 'center';
                button.style.justifyContent = 'center';
                
                // Handle fullscreen toggle
                L.DomEvent.on(button, 'click', function(e) {
                    L.DomEvent.stopPropagation(e);
                    L.DomEvent.preventDefault(e);
                    
                    const mapContainer = document.getElementById('map');
                    const primaryContainer = document.querySelector('.primary-view-container');
                    
                    // Check if we're in fullscreen mode
                    const isFullscreen = document.fullscreenElement || 
                                        document.webkitFullscreenElement || 
                                        document.mozFullScreenElement || 
                                        document.msFullscreenElement;
                    
                    if (!isFullscreen) {
                        // Enter fullscreen - try all possible methods
                        try {
                            if (mapContainer.requestFullscreen) {
                                mapContainer.requestFullscreen();
                            } else if (mapContainer.webkitRequestFullscreen) { /* Safari */
                                mapContainer.webkitRequestFullscreen();
                            } else if (mapContainer.mozRequestFullScreen) { /* Firefox */
                                mapContainer.mozRequestFullScreen();
                            } else if (mapContainer.msRequestFullscreen) { /* IE/Edge */
                                mapContainer.msRequestFullscreen();
                            } else {
                                // Fallback for mobile browsers that don't support fullscreen API
                                mapContainer.classList.add('fullscreen-map');
                                if (primaryContainer) primaryContainer.classList.add('fullscreen-container');
                            }
                            
                            // Add class for styling
                            mapContainer.classList.add('fullscreen-map');
                            if (primaryContainer) primaryContainer.classList.add('fullscreen-container');
                            
                            // Update button title
                            button.title = 'Exit Fullscreen';
                            
                            // Invalidate map size after a short delay
                            setTimeout(function() {
                                map.invalidateSize();
                            }, 200);
                            
                            console.log('Entered fullscreen mode');
                        } catch (err) {
                            console.error('Fullscreen error:', err);
                            // Fallback for browsers where fullscreen request failed
                            mapContainer.classList.add('fullscreen-map');
                            if (primaryContainer) primaryContainer.classList.add('fullscreen-container');
                            map.invalidateSize();
                        }
                    } else {
                        // Exit fullscreen - try all possible methods
                        try {
                            if (document.exitFullscreen) {
                                document.exitFullscreen();
                            } else if (document.webkitExitFullscreen) { /* Safari */
                                document.webkitExitFullscreen();
                            } else if (document.mozCancelFullScreen) { /* Firefox */
                                document.mozCancelFullScreen();
                            } else if (document.msExitFullscreen) { /* IE/Edge */
                                document.msExitFullscreen();
                            } else {
                                // Fallback for mobile browsers that don't support fullscreen API
                                mapContainer.classList.remove('fullscreen-map');
                                if (primaryContainer) primaryContainer.classList.remove('fullscreen-container');
                            }
                            
                            // Remove class
                            mapContainer.classList.remove('fullscreen-map');
                            if (primaryContainer) primaryContainer.classList.remove('fullscreen-container');
                            
                            // Update button title
                            button.title = 'View Fullscreen';
                            
                            // Invalidate map size after a short delay
                            setTimeout(function() {
                                map.invalidateSize();
                            }, 200);
                            
                            console.log('Exited fullscreen mode');
                        } catch (err) {
                            console.error('Exit fullscreen error:', err);
                            // Fallback for browsers where fullscreen exit failed
                            mapContainer.classList.remove('fullscreen-map');
                            if (primaryContainer) primaryContainer.classList.remove('fullscreen-container');
                            map.invalidateSize();
                        }
                    }
                    
                });
                
                // Add event listener for fullscreenchange events
                document.addEventListener('fullscreenchange', handleFullscreenChange);
                document.addEventListener('webkitfullscreenchange', handleFullscreenChange);
                document.addEventListener('mozfullscreenchange', handleFullscreenChange);
                document.addEventListener('MSFullscreenChange', handleFullscreenChange);
                
                function handleFullscreenChange() {
                    const mapContainer = document.getElementById('map');
                    const primaryContainer = document.querySelector('.primary-view-container');
                    
                    if (!document.fullscreenElement && 
                        !document.webkitFullscreenElement && 
                        !document.mozFullScreenElement && 
                        !document.msFullscreenElement) {
                        // We've exited fullscreen mode
                        mapContainer.classList.remove('fullscreen-map');
                        if (primaryContainer) primaryContainer.classList.remove('fullscreen-container');
                        if (button) button.title = 'View Fullscreen';
                        map.invalidateSize();
                    }
                }
                
                return container;
            }
        });
        
        // Add the custom fullscreen control to the map
        map.addControl(new fullscreenControl());
        let markerLayer; // Declare markerLayer here

        // Add Tile Layer (OpenStreetMap)
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            maxZoom: 19,
            attribution: '&copy; <a href="http://www.openstreetmap.org/copyright">OpenStreetMap</a>'
        }).addTo(map);

        // Initialize marker layer and add to map
        markerLayer = L.layerGroup().addTo(map);

        // Function to add details to popup safely
        function addDetail(popupContent, label, value) {
            if (value !== null && value !== undefined && String(value).trim() !== '') {
                popupContent += `<p><strong>${formatColumnName(label)}:</strong> ${String(value)}</p>`;
            }
            return popupContent;
        }

        // --- Chef Data Processing ---
        let chefsData = [];
        try {
            // Retrieve the JSON string from the dedicated script tag
            const jsonDataElement = document.getElementById('chefs-data');
            if (!jsonDataElement) {
                throw new Error("Could not find chefs-data script tag.");
            }
            const rawJsonData = jsonDataElement.textContent || jsonDataElement.innerText;
            // Parse the retrieved JSON string
            chefsData = JSON.parse(rawJsonData);

            if (!Array.isArray(chefsData)) {
                throw new Error("Parsed data is not a valid array.");
            }
        } catch (e) {
            console.error("Error processing chef JSON data:", e);
            const mapDiv = document.getElementById('map');
            if (mapDiv) {
                mapDiv.innerHTML = '<p style="color: red; padding: 20px;">Error loading chef data for the map.</p>';
            }
        }

        // --- Marker Creation ---
        if (Array.isArray(chefsData)) {
            chefsData.forEach(chef => {
                const lat = parseFloat(chef.latitude);
                const lon = parseFloat(chef.longitude);

                if (!isNaN(lat) && !isNaN(lon)) {
                    const marker = L.marker([lat, lon]); // Don't add to map directly, add to layer group later

                    let popupContent = `<div class="popup-container">`; // Container div for styling
                    popupContent += `<h3 class="popup-header">${chef.name || 'Unknown Chef'}</h3>`;

                    // 1. Add Image (if exists) - Centered below header
                    if(chef.image_url) {
                        popupContent += `<img src="${chef.image_url}" alt="Image of ${chef.name || 'chef'}" class="popup-image">`;
                    }

                    // 2. Add Prioritized Fields
                    const priorityFields = ['restaurant_address', 'status', 'season_number'];
                    priorityFields.forEach(colName => {
                        if (chef[colName] !== null && chef[colName] !== undefined && String(chef[colName]).trim() !== '') {
                            popupContent += `<p class="popup-field"><strong>${formatColumnName(colName)}:</strong> ${String(chef[colName])}</p>`;
                        }
                    });

                    // 2b. Add Google Maps Link
                    const mapsUrl = `https://www.google.com/maps?q=${lat},${lon}`;
                    popupContent += `<p class="popup-field popup-map-link"><a href="${mapsUrl}" target="_blank" title="View on Google Maps">View on Map</a></p>`;

                    // 3. Add Remaining Relevant Fields
                    if (globalColumnNames && globalColumnNames.length > 0) {
                        const excludedFields = ['id', 'name', 'image_url', 'restaurant_address', 'status', 'season_number', 'latitude', 'longitude', 'perplexity_data', 'last_updated'];
                        globalColumnNames.forEach(colName => { 
                            if (!excludedFields.includes(colName)) {
                                if (chef[colName] !== null && chef[colName] !== undefined && String(chef[colName]).trim() !== '') {
                                    popupContent += `<p class="popup-field"><strong>${formatColumnName(colName)}:</strong> ${String(chef[colName])}</p>`;
                                }
                            }
                        }); 
                    } else {
                        popupContent += '<p>Details unavailable.</p>'; // Fallback
                    }

                    popupContent += `</div>`; // Close container div

                    marker.bindPopup(popupContent);
                    marker.addTo(markerLayer); // Add to layer group
                }
            });
        } else {
            console.error("Chef data is not an array after processing:", chefsData);
        }

        // --- Log Viewer Logic ---
        const spinnerElement = document.getElementById('loading-spinner');
        let allLogs = []; // Maintain all logs in memory for filtering/searching if needed later

        // --- Functions ---

        // Helper to save logs to localStorage
        function saveLogsToStorage(key, logsArray) {
            try {
                localStorage.setItem(key, JSON.stringify(logsArray.slice(-maxLogEntries))); // Store only the last N logs
            } catch (e) {
                console.error(`Error saving logs to localStorage (${key}):`, e);
            }
        }

        // Helper to load logs from localStorage
        function loadLogsFromStorage(key) {
            try {
                const storedLogs = localStorage.getItem(key);
                return storedLogs ? JSON.parse(storedLogs) : [];
            } catch (e) {
                console.error(`Error loading logs from localStorage (${key}):`, e);
                return [];
            }
        }

        // Function to format structured log data (re-added)
        function formatLogData(log) {
            if (!log || !log.data) return 'Invalid log data';

            // Basic formatting - can be expanded
            if (typeof log.data === 'object') {
                // Handle different message formats
                if (log.data.content) {
                    return log.data.content; // Return content directly
                } else if (log.data.message) {
                    return log.data.message; // Return message directly
                } else if (log.data.count && log.data.calls) {
                    // For tool call summaries, format them nicely
                    return `<em>Executing ${log.data.count} tool call(s)...</em>`;
                    // Don't show the raw JSON for tool calls in the main chat
                } else {
                    // Try to find any string field that might contain a message
                    let foundMessage = false;
                    for (const key in log.data) {
                        if (typeof log.data[key] === 'string' && log.data[key].length > 5) {
                            return log.data[key];
                            foundMessage = true;
                            break;
                        }
                    }
                    
                    if (!foundMessage) {
                        // If no suitable field found, use the formatter but hide in main chat
                        return "<em>Processing...</em>";
                    }
                }
            }
            // Fallback for non-objects (though addLogEntry handles strings separately)
            return String(log.data);
        }

        // Modified addLogEntry to handle both background and interactive logs, and save to storage
        function addLogEntry(log, areaElement, storageKey, logArray) {
            console.log('[addLogEntry] Received log:', log, 'Target Area:', areaElement ? areaElement.id : 'UNKNOWN'); // Debug: Log received data and target
            if (!log || !areaElement) {
                console.error('[addLogEntry] Error: Invalid log object or areaElement provided.', log, areaElement);
                return;
            }

            const logEntryElement = document.createElement('div');
            logEntryElement.classList.add('log-entry');

            let role = log.role || 'system'; // Default role
            let messageContent = '';
            let timestamp = log.timestamp ? new Date(log.timestamp * 1000).toLocaleTimeString() : new Date().toLocaleTimeString();

            // Determine class based on role
            if (role === "StephAI Botenberg") { // Use hardcoded agent name for comparison
                logEntryElement.classList.add('log-entry-agent');
            } else if (role === 'user') {
                logEntryElement.classList.add('user-msg');
            } else if (role === 'system' || role === 'autonomous_agent') {
                logEntryElement.classList.add('log-entry-system');
            } else if (role === 'tool_executor') {
                logEntryElement.classList.add('log-entry-tool');
            } else {
                logEntryElement.classList.add('log-entry-info'); // Default/other
            }

            // Format message content based on log type or data structure
            if (typeof log.data === 'string') {
                messageContent = log.data;
            } else if (typeof log.data === 'object' && log.data !== null) {
                // Special handling for agent messages with various field structures
                if (log.role === "StephAI Botenberg") {
                    // Handle different message formats from the agent
                    if (log.data.content) {
                        messageContent = log.data.content; // Use content field directly
                    } else if (log.data.message) {
                        messageContent = log.data.message; // Use message field directly
                    } else if (log.data.count && log.data.calls) {
                        // For tool call summaries, format them nicely
                        messageContent = `<em>Executing ${log.data.count} tool call(s)...</em>`;
                        // Don't show the raw JSON for tool calls in the main chat
                    } else {
                        // Try to find any string field that might contain a message
                        let foundMessage = false;
                        for (const key in log.data) {
                            if (typeof log.data[key] === 'string' && log.data[key].length > 5) {
                                messageContent = log.data[key];
                                foundMessage = true;
                                break;
                            }
                        }
                        
                        if (!foundMessage) {
                            // If no suitable field found, use the formatter but hide in main chat
                            messageContent = "<em>Processing...</em>";
                        }
                    }
                } else {
                    messageContent = formatLogData(log); // Use existing formatter for non-agent messages
                }
            } else if (log.response) { // For interactive agent responses
                messageContent = log.response;
            } else if (log.error) { // For errors
                messageContent = `Error: ${log.error}`;
                logEntryElement.classList.add('log-entry-error');
            } else {
                messageContent = JSON.stringify(log); // Fallback
            }

            const timestampElement = document.createElement('span');
            timestampElement.classList.add('log-timestamp');
            timestampElement.textContent = `[${timestamp}]`;

            const roleElement = document.createElement('span');
            roleElement.classList.add('log-role');
            roleElement.textContent = role;

            const messageContentElement = document.createElement('span');
            messageContentElement.innerHTML = messageContent; // Use innerHTML for potential formatting from formatLogData

            logEntryElement.appendChild(timestampElement);
            logEntryElement.appendChild(roleElement);
            logEntryElement.appendChild(messageContentElement);

            console.log('[addLogEntry] Created element:', logEntryElement); // Debug: Log the created element

            try {
                areaElement.appendChild(logEntryElement);
                console.log('[addLogEntry] Successfully appended element to:', areaElement.id); // Debug: Confirm append
            } catch (error) {
                console.error('[addLogEntry] FAILED to append element to:', areaElement.id, error); // Debug: Log append failure
                 // Optionally display an error in the log area itself
                 const errorElement = document.createElement('div');
                 errorElement.className = 'log-entry log-entry-error';
                 errorElement.textContent = `[UI Error] Failed to display log entry. See console.`;
                 areaElement.appendChild(errorElement);
            }

            // Auto-scroll to the bottom
            areaElement.scrollTop = areaElement.scrollHeight;
            // Add to the in-memory array and save to storage
            logArray.push(log); // Store the original log object
            saveLogsToStorage(storageKey, logArray);

            // Remove oldest entries if exceeding max
            while (areaElement.children.length > maxLogEntries) {
                areaElement.removeChild(areaElement.firstChild);
            }
            // Also trim the in-memory array if needed (though saveLogs already slices)
            if (logArray.length > maxLogEntries * 1.1) { // Keep a bit more in memory just in case
                 logArray.splice(0, logArray.length - maxLogEntries);
            }

            // Hide spinner after first message (if it exists)
            if (spinnerElement) {
                spinnerElement.style.display = 'none';
            }
        }

        // Load initial logs from storage
        let backgroundLogs = loadLogsFromStorage(BACKGROUND_LOG_KEY);
        backgroundLogs.forEach(log => addLogEntry(log, backgroundLogArea, BACKGROUND_LOG_KEY, backgroundLogs));

        let interactiveLogs = loadLogsFromStorage(INTERACTIVE_LOG_KEY); // Load interactive logs earlier
        interactiveLogs.forEach(log => addLogEntry(log, interactiveLogArea, INTERACTIVE_LOG_KEY, interactiveLogs));

        let mainLogs = loadLogsFromStorage(MAIN_LOG_KEY); // Load main chat logs
        mainLogs.forEach(log => addLogEntry(log, chatLogArea, MAIN_LOG_KEY, mainLogs)); // Populate main chat area

        // Interactive logs handled by interactive_chat.js

        // --- SSE Connection (Background Logs) ---
        const eventSource = new EventSource("/stream_logs");

        eventSource.onopen = function() {
            console.log("SSE connection opened for background logs.");
            // Optional: add a visual indicator
        };

        eventSource.onmessage = function(event) {
            // Ignore empty messages or potential keep-alive pings
            if (!event.data || !event.data.trim()) {
                // console.debug("SSE: Received empty message.");
                return;
            }
            // Check if data looks like JSON before parsing
            const potentialJson = event.data.trim();
            if (potentialJson.startsWith('{') || potentialJson.startsWith('[')) {
                try {
                    const logData = JSON.parse(potentialJson);
                    if (logData.type === 'stream_error') {
                        console.error('SSE Stream Error:', logData.data.error);
                        addLogEntry({ role: 'system', data: `Stream Error: ${logData.data.error}`, timestamp: Date.now()/1000, type: 'error' }, backgroundLogArea, BACKGROUND_LOG_KEY, backgroundLogs);
                    } else if (logData.type) { // Basic check for a valid log structure
                        // Route based on role
                        if (logData.role === "StephAI Botenberg") {
                             // Send Agent's main messages to the main chat area
                             console.log(`Routing log from ${logData.role} to main chat area.`);
                             addLogEntry(logData, chatLogArea, MAIN_LOG_KEY, mainLogs);
                        } else {
                             // Send system/tool logs to the background area
                             console.log(`Routing log from ${logData.role || 'unknown'} to background area.`);
                             addLogEntry(logData, backgroundLogArea, BACKGROUND_LOG_KEY, backgroundLogs);
                        }
                    } else {
                         console.warn("SSE: Received JSON data without 'type' field: ", logData);
                    }
                } catch (e) {
                    console.error("Error parsing seemingly valid JSON from SSE:", event.data, e);
                     addLogEntry({ type: 'db_stream_error', data: `Failed processing log data: ${e.message}`, timestamp: Date.now() / 1000, role: 'system' }, backgroundLogArea, BACKGROUND_LOG_KEY, backgroundLogs);
                }
            } else {
                 // Silently ignore non-JSON messages (likely keep-alives)
                 console.debug("SSE: Ignored non-JSON message: ", event.data);
            }
        };

        eventSource.onerror = function(err) {
            console.error("SSE Error occurred:", err);
            addLogEntry({ type: 'db_stream_error', data: 'Log stream connection error. Trying to reconnect...', timestamp: Date.now() / 1000, role: 'system' }, backgroundLogArea, BACKGROUND_LOG_KEY, backgroundLogs);
            // EventSource automatically attempts to reconnect.
            // Consider closing after too many errors: eventSource.close();
        };

        // --- Restored Database Table, Filtering, View Toggle, and DB Update Logic ---
        let tableLoaded = false; // Tracks initial load
        const tablePlaceholder = document.getElementById('table-placeholder');
        const tableContainer = document.getElementById('database-table-container'); // Get container reference

        async function refreshTableData(season = null) {
            console.log("Refreshing table data...", season ? `for season ${season}` : '');
            tablePlaceholder.textContent = 'Refreshing database content...'; // Update placeholder text
            tablePlaceholder.style.color = '#666'; // Reset color
            tableLoaded = false; // Reset flag to allow reload display logic

            // Clear existing table if it exists within the wrapper
            const existingWrapper = tablePlaceholder.querySelector('.db-table-wrapper');
            if (existingWrapper) {
                tablePlaceholder.removeChild(existingWrapper);
            }
            // Fetch potentially filtered data
            const chefs = await fetchChefs(season);
            await loadAndDisplayTable(chefs); // Call the main loading function with fetched data
        }

        async function loadAndDisplayTable(chefs) {
            const tableBody = document.getElementById('database-table-body');
            const tableHead = document.getElementById('database-table-head');
            if (!tableBody || !tableHead) {
                console.error("Table body or head not found!");
                return;
            }

            // Clear existing table content
            tableHead.innerHTML = '';
            tableBody.innerHTML = '';

            if (!chefs || chefs.length === 0 || !globalColumnNames || globalColumnNames.length === 0) {
                // Ensure table container exists before modifying innerHTML
                if (tableContainer) {
                    tableContainer.innerHTML = '<p>No chef data or column definition available.</p>';
                    tablePlaceholder.style.display = 'none';
                    tableContainer.style.display = 'block'; // Show the container with the message
                } else {
                     console.error("Table container not found!");
                }
                return;
            }

            // --- Create Table Header dynamically ---
            const headerRow = document.createElement('tr');
            globalColumnNames.forEach(colName => {
                const th = document.createElement('th');
                th.textContent = formatColumnName(colName); // Now this function exists
                headerRow.appendChild(th);
            });
            tableHead.appendChild(headerRow);

            // --- Populate Table Body dynamically ---
            chefs.forEach(chef => {
                const row = document.createElement('tr');
                globalColumnNames.forEach(colName => {
                    const td = document.createElement('td');
                    let value = chef[colName];

                    // Add data-label attribute for mobile view
                    td.setAttribute('data-label', formatColumnName(colName));

                    // Handle specific formatting
                    if (colName === 'perplexity_data' && typeof value === 'object' && value !== null) {
                        const pre = document.createElement('pre');
                        pre.style.whiteSpace = 'pre-wrap'; // Ensure JSON wraps
                        pre.style.wordBreak = 'break-all'; // Ensure long strings break
                        pre.textContent = JSON.stringify(value, null, 2); // Pretty print JSON
                        td.appendChild(pre);
                    } else if (colName === 'image_url' && value) {
                        const img = document.createElement('img');
                        img.src = value;
                        img.alt = `Image of ${chef.name || 'chef'}`;
                        img.style.maxWidth = '50px'; img.style.maxHeight = '50px'; img.style.display = 'block';
                        img.onerror = () => { td.textContent = '(No Image)'; };
                        td.appendChild(img);
                    } else {
                       td.textContent = (value !== null && value !== undefined) ? String(value) : ''; // Handle null/undefined, ensure string
                    }
                    row.appendChild(td);
                });
                tableBody.appendChild(row);
            });

             // Ensure container is visible after loading
             if (tablePlaceholder) tablePlaceholder.style.display = 'none';
             // Ensure the container uses block display, not table display for consistency
             if (tableContainer) tableContainer.style.display = 'block';
        }

        // Function to format DB column names into readable labels
        function formatColumnName(name) {
            if (!name) return '';
            // Replace underscores with spaces, capitalize first letter of each word
            return name.replace(/_/g, ' ')
                       .replace(/\b\w/g, char => char.toUpperCase());
        }

        // --- View Toggle Logic ---
        const toggleButton = document.getElementById('view-toggle-button');
        const mapContainer = document.getElementById('map');
        // tableContainer is already defined above
        let currentView = 'map'; // Assume map is default

        toggleButton.addEventListener('click', async () => {
            if (currentView === 'map') {
                // Switch to Table View
                mapContainer.style.display = 'none';
                tableContainer.style.display = 'block'; // Use block display
                toggleButton.textContent = 'Show Map';
                currentView = 'table';
                // Load table data based on the *current* season filter
                const selectedSeason = document.getElementById('season-filter').value;
                const chefsToDisplay = filterChefsBySeason(allChefs, selectedSeason);
                await loadAndDisplayTable(chefsToDisplay);
            } else {
                // Switch to Map View
                tableContainer.style.display = 'none';
                mapContainer.style.display = 'block';
                toggleButton.textContent = 'Show Table';
                currentView = 'map';
                // Update map markers based on the current season filter
                const selectedSeason = document.getElementById('season-filter').value;
                const chefsToDisplay = filterChefsBySeason(allChefs, selectedSeason);
                updateMapMarkers(chefsToDisplay); // Assumes updateMapMarkers exists and handles clearing/adding
                setTimeout(() => {
                    map.invalidateSize(); // Ensure map resizes correctly
                }, 10);
            }
        });

        // --- SSE Connection for Database Updates ---
        const dbUpdateEventSource = new EventSource("/stream_db_updates");

        dbUpdateEventSource.onopen = function() {
            console.log("DB Update SSE Connected");
        };

        dbUpdateEventSource.onmessage = async function(event) {
            try {
                const updateSignal = JSON.parse(event.data);
                console.log("Received DB update signal:", updateSignal);
                if (updateSignal.event === "update") {
                    // 1. Re-fetch all data to update the global 'allChefs' array
                    allChefs = await fetchChefs(); // Fetch all initially
                    console.log("Refetched all chef data after update signal.");
                    // 2. Get current filter
                    const selectedSeason = document.getElementById('season-filter').value;
                    // 3. Filter the newly fetched data
                    const chefsToDisplay = filterChefsBySeason(allChefs, selectedSeason);
                    // 4. Update the currently active view
                    if (currentView === 'table') {
                        console.log("Refreshing table view after update signal.");
                        await loadAndDisplayTable(chefsToDisplay);
                    } else {
                        console.log("Refreshing map view after update signal.");
                        updateMapMarkers(chefsToDisplay); // Update map markers
                    }
                    // 5. Repopulate season filter in case seasons changed
                    populateSeasonFilter(allChefs);
                }
            } catch (e) {
                console.error("Failed to parse DB Update SSE data or refresh view:", event.data, e);
                addLogEntry({ type: 'db_stream_error', data: `Failed processing DB update signal: ${e.message}`, timestamp: Date.now() / 1000, role: 'system' }, backgroundLogArea, BACKGROUND_LOG_KEY, backgroundLogs);
            }
        };

        dbUpdateEventSource.onerror = function(err) {
            console.error("DB Update EventSource failed:", err);
            addLogEntry({ type: 'db_stream_error', data: 'DB Update stream connection error. Check console.', timestamp: Date.now() / 1000, role: 'system' }, backgroundLogArea, BACKGROUND_LOG_KEY, backgroundLogs);
        };

        // --- Table and Map Data Loading / Filtering ---
        let allChefs = []; // Holds all chef data fetched initially or after update

        // Populate the season filter dropdown based on chef data
        function populateSeasonFilter(chefs) {
            const seasonSet = new Set();
            chefs.forEach(chef => {
                if (chef.season !== undefined && chef.season !== null) {
                    seasonSet.add(chef.season);
                }
            });
            const seasonFilter = document.getElementById('season-filter');
            const currentValue = seasonFilter.value; // Preserve selection if possible
            // Remove old options except 'All'
            seasonFilter.querySelectorAll('option:not([value=""])').forEach(opt => opt.remove());
            Array.from(seasonSet).sort((a, b) => a - b).forEach(season => {
                const opt = document.createElement('option');
                opt.value = season;
                opt.textContent = `Season ${season}`;
                seasonFilter.appendChild(opt);
            });
            // Try to restore previous selection, default to 'All' if it's gone
             if (Array.from(seasonFilter.options).some(opt => opt.value === currentValue)) {
                 seasonFilter.value = currentValue;
             } else {
                 seasonFilter.value = ""; // Default to 'All'
             }
        }

        // Filter chefs by selected season (accepts string or number for season)
        function filterChefsBySeason(chefs, season) {
            if (season === null || season === "" || season === undefined) return chefs; // Handle 'All Seasons'
            const seasonNum = parseInt(season, 10);
            return chefs.filter(chef => chef.season === seasonNum);
        }

        // Update Map Markers (Moved definition here)
        function updateMapMarkers(chefsToDisplay) {
            markerLayer.clearLayers(); // Clear existing markers
            chefsToDisplay.forEach(chef => {
                if (chef.latitude != null && chef.longitude != null) {
                     try {
                        const lat = parseFloat(chef.latitude);
                        const lon = parseFloat(chef.longitude);
                        if (!isNaN(lat) && !isNaN(lon)) {
                            const marker = L.marker([lat, lon]);

                            // --- Build Popup Content dynamically ---
                            let popupContent = `<div class="popup-container">`;
                            popupContent += `<h3 class="popup-header">${chef.name || 'Unknown Chef'}</h3>`;

                            // 1. Add Image (if exists) - Centered below header
                            if(chef.image_url) {
                                popupContent += `<img src="${chef.image_url}" alt="Image of ${chef.name || 'chef'}" class="popup-image">`;
                            }

                            // 2. Add Prioritized Fields
                            const priorityFields = ['restaurant_address', 'status', 'season_number'];
                            priorityFields.forEach(colName => {
                                if (chef[colName] !== null && chef[colName] !== undefined && String(chef[colName]).trim() !== '') {
                                    popupContent += `<p class="popup-field"><strong>${formatColumnName(colName)}:</strong> ${String(chef[colName])}</p>`;
                                }
                            });

                            // 2b. Add Google Maps Link
                            const mapsUrl = `https://www.google.com/maps?q=${lat},${lon}`;
                            popupContent += `<p class="popup-field popup-map-link"><a href="${mapsUrl}" target="_blank" title="View on Google Maps">View on Map</a></p>`;

                            // 3. Add Remaining Relevant Fields
                            if (globalColumnNames && globalColumnNames.length > 0) {
                                const excludedFields = ['id', 'name', 'image_url', 'restaurant_address', 'status', 'season_number', 'latitude', 'longitude', 'perplexity_data', 'last_updated'];
                                globalColumnNames.forEach(colName => { 
                                    if (!excludedFields.includes(colName)) {
                                        if (chef[colName] !== null && chef[colName] !== undefined && String(chef[colName]).trim() !== '') {
                                            popupContent += `<p class="popup-field"><strong>${formatColumnName(colName)}:</strong> ${String(chef[colName])}</p>`;
                                        }
                                    }
                                }); 
                            } else {
                                popupContent += '<p>Details unavailable.</p>'; // Fallback
                            }

                            popupContent += `</div>`; // Close container div

                            marker.bindPopup(popupContent);
                            marker.addTo(map);
                        }
                     } catch(e) {
                         console.error(`Error processing marker for chef ID ${chef.id}:`, e);
                     }
                } else {
                     // Optional: Log missing coordinates
                     // console.warn(`Skipping chef ID ${chef.id}: Missing coordinates.`);
                }
            });
            // Optional: Log marker update
            // console.log(`Updated map with ${currentMarkers.length} markers.`);
        }

        // Listen for season filter changes
        document.getElementById('season-filter').addEventListener('change', async function() {
            const selectedSeason = this.value;
            // Filter the existing 'allChefs' data
            const chefsToDisplay = filterChefsBySeason(allChefs, selectedSeason);
            // Update the currently active view
            if (currentView === 'table') {
                await loadAndDisplayTable(chefsToDisplay);
            } else {
                updateMapMarkers(chefsToDisplay);
            }
        });

        // Enlarging chat windows logic
        const sidebar = document.querySelector('.sidebar');
        const enlargeAgent = document.getElementById('enlarge-agent');
        const enlargeBg = document.getElementById('enlarge-bg');
        const enlargeInteractive = document.getElementById('enlarge-interactive');
        function toggleEnlarge(which) {
            if (!sidebar) return; // Safety check
            const targetClass = 'enlarged-' + which;
            if (sidebar.classList.contains(targetClass)) {
                 sidebar.classList.remove(targetClass);
            } else {
                sidebar.classList.remove('enlarged-agent', 'enlarged-bg', 'enlarged-interactive'); // Remove any existing enlarge class
                sidebar.classList.add(targetClass);
            }
        }
        if (enlargeAgent) enlargeAgent.addEventListener('click', function() { toggleEnlarge('agent'); });
        if (enlargeBg) enlargeBg.addEventListener('click', function() { toggleEnlarge('bg'); });
        if (enlargeInteractive) enlargeInteractive.addEventListener('click', function() { toggleEnlarge('interactive'); });

        // Fetch chefs from backend with optional season param
        async function fetchChefs(season = null) {
            let url = '/api/chefs';
            // Only add season param if it's a specific season (not empty string for 'All')
            if (season !== null && season !== "") {
                 url += `?season=${season}`;
            }
            try {
                const response = await fetch(url);
                 if (!response.ok) {
                     throw new Error(`API fetch error! status: ${response.status}`);
                 }
                 return await response.json();
            } catch (error) {
                 console.error('Failed to fetch chefs:', error);
                 tablePlaceholder.textContent = `Error fetching chef data: ${error.message}.`;
                 tablePlaceholder.style.color = 'red';
                 return []; // Return empty array on error
            }
        }

        // --- Background Log Collapse/Expand Logic (Now follows restored code) ---
        const backgroundHeader = document.getElementById('background-header');
        const backgroundContainer = document.getElementById('background-work-container');
        const toggleIcon = backgroundHeader.querySelector('.toggle-icon');

        backgroundHeader.addEventListener('click', () => {
            backgroundContainer.classList.toggle('collapsed');
            if (backgroundContainer.classList.contains('collapsed')) {
                toggleIcon.textContent = '+';
            } else {
                toggleIcon.textContent = '-';
                // Scroll to bottom when expanding
                backgroundLogArea.scrollTop = backgroundLogArea.scrollHeight;
            }
        });

        // --- Initial Load --- Execute async function (Modified)
        (async function() {
            allChefs = await fetchChefs(); // Fetch all initially
            populateSeasonFilter(allChefs); // Populate filter based on fetched data
            updateMapMarkers(allChefs); // Initial map display (all seasons)
            // Initial table load ONLY if table view is the default/active on load
            if (currentView === 'table') { // Check currentView state determined by toggle logic
                 await loadAndDisplayTable(allChefs);
            }
            // Ensure spinner is hidden after initial load attempts
            if (spinnerElement) {
                spinnerElement.style.display = 'none';
            }
        })();

        // Setup interactive chat
        (function setupInteractiveChat() {
            const inputElement = document.getElementById('interactive-chat-input');
            const sendButton = document.getElementById('interactive-chat-send');
            const logArea = document.getElementById('interactive-chat-log-area');
            const storageKey = 'interactiveLogs';
            let logs = []; // Use a local array for interactive logs

            const sendMessage = async () => {
                const message = inputElement.value.trim();
                if (message === '') {
                    return; // Don't send empty messages
                }

                // Add user message to log
                const userLog = { message: message, source: 'user', timestamp: new Date().toISOString() };
                addLogEntry(userLog, logArea, storageKey, logs);
                inputElement.value = ''; // Clear input field

                // Add thinking indicator
                const thinkingLog = { message: 'Thinking...', source: 'agent', timestamp: new Date().toISOString(), type: 'thinking' };
                const thinkingElement = addLogEntry(thinkingLog, logArea, storageKey, logs, true); // Add temporarily

                try {
                    const response = await fetch('/interactive_chat', { // Corrected URL
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({ message: message }), // Corrected payload key
                    });

                    // Remove thinking indicator
                    if (thinkingElement) {
                        logArea.removeChild(thinkingElement);
                        // Also remove from the logs array if it was added temporarily
                        logs.pop(); 
                        // Note: This assumes thinking log was the last one added temporarily. 
                        // A more robust approach might involve IDs if needed.
                    }

                    if (!response.ok) {
                        const errorData = await response.json().catch(() => ({ error: 'Failed to parse error response.' }));
                        throw new Error(errorData.error || `HTTP error! status: ${response.status}`);
                    }

                    const data = await response.json();

                    // Add agent response to log
                    const agentLog = { message: data.response, source: 'agent', timestamp: new Date().toISOString() };
                    addLogEntry(agentLog, logArea, storageKey, logs);

                } catch (error) {
                     // Remove thinking indicator even if there's an error
                    if (thinkingElement && thinkingElement.parentNode === logArea) {
                        logArea.removeChild(thinkingElement);
                         logs.pop(); // Remove from array as well
                    }
                    console.error('Error sending message:', error);
                    const errorLog = { message: `Error: ${error.message}`, source: 'system', type: 'error', timestamp: new Date().toISOString() };
                    addLogEntry(errorLog, logArea, storageKey, logs);
                }
            };

            sendButton.addEventListener('click', sendMessage);

            inputElement.addEventListener('keypress', (event) => {
                if (event.key === 'Enter') {
                    event.preventDefault(); // Prevent default form submission/newline
                    sendMessage();
                }
            });
        })();
        
        // --- Map Fullscreen Logic ---
        const mapElement = document.getElementById('map');
        const fullscreenButton = document.getElementById('fullscreen-map-button');

        if (fullscreenButton && mapElement) {
            fullscreenButton.addEventListener('click', () => {
                if (!document.fullscreenElement) {
                    // Enter fullscreen
                    mapElement.requestFullscreen().catch(err => {
                        console.error(`Error attempting to enable full-screen mode: ${err.message} (${err.name})`);
                        alert(`Error attempting to enable full-screen mode: ${err.message}`);
                    });
                } else {
                    // Exit fullscreen
                    document.exitFullscreen();
                }
            });
        }
        // Optional: Listen for fullscreen change events to update button icon/state if needed
        document.addEventListener('fullscreenchange', () => {
             if (document.fullscreenElement === mapElement) {
                 fullscreenButton.innerHTML = '&#x2923;'; // Change icon to exit fullscreen symbol
                 fullscreenButton.title = 'Exit Fullscreen';
             } else {
                 fullscreenButton.innerHTML = '&#x2922;'; // Change back to enter fullscreen symbol
                 fullscreenButton.title = 'Toggle Fullscreen';
             }
        });
    </script>
    <!-- Load the interactive chat JavaScript -->
    <script>
        // Make necessary functions/variables global or pass them carefully
        window.addLogEntry = addLogEntry;
        window.interactiveLogArea = interactiveLogArea;
        window.INTERACTIVE_LOG_KEY = INTERACTIVE_LOG_KEY;
        window.interactiveLogs = interactiveLogs; // Pass the initially loaded logs
    </script>
    <script src="{{ url_for('static', filename='interactive_chat.js') }}"></script>
</body>
</html>
